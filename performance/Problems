This document lists the main problems we have to solve in order to modify the initial protocol, and the eventual solutions:

Problem 1:
In order to create the multiple random strings (or in the case of choosing the main secret to solve, one bit) we need to be able to get random numbers securely.

This can be achieved using the OpenSSL random number generator included in Charm toolboxes found at the following link:
https://jhuisi.github.io/charm/toolbox/securerandom.html

Therefore, at the beginning of the program, we need to add:
from charm.toolbox.securerandom import OpenSSLRand

And then we can use the getRandomBits(length) in order to achieve our objective.


Problem 2:
We need to separate as much random generation as possible from the rest of the protocol as possible, to get a better idea of what actually takes time.

This can be done by adding an additional prover state (prover_trans = { 0:1, 1:3, 3:5, 5:0 }) for instance.


Problem 3: 
Contrary to the basic Schnorr protocol, we generate two challenges (c0 and c1) using the OpenSSL random generator in the first verifier state (verifier_state2).

We then send both of those challenges to the prover, which has to completely solve one (depending on a random bit b also generated by the verifier).

s0 = r + c0 * x and s1 = r + c1 * x is then solved by the prover. The prover must know the responses to both challenges in order to complete the protocol. However he only sends one complete response (depending on the value of b), and l bits of the other challenge.

I'm uncertain as to how to determine l and the send the partial responde to the challenge back to the verifier.

Problem 4: 
The original protocol is made to handle exchanges between two servers operating as prover/verifier, however we don't need that to get performance evaluations.
