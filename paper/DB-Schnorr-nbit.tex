\section{Bit-by-bit distance-bounding Schnorr protocol}%
\label{DB-Schnorr-nbit}

We will now continue with a more traditional (in \ac{DB} terms) version of the 
protocol, one that uses bit-by-bit communication.
As mentioned in \cref{related-work}, while there exists a \iac{PPK} 
protocol~\cite{ProProx}, there is none for discrete logarithms. We will now introduce such a protocol to enable us to have \ac{DB} anonymous credentials.

%One protocol exists in the literature that provides \acp{PPK} with most of the desired properties described previously, ProProx~\cite{ProProx}\footnote{Note that~\cite{ProProx} uses the abbreviation PoPoK, we prefer \acs{PPK} for shorter notation.}.
%ProProx is secure against a malicious verifier, but it provides \iac{PPK} protocol for quadratic residues (\ie protocols of the form \(\PPK[\alpha][a = 
%  \alpha^2]\)), while in our context, we need \iac{PPK} protocol for discrete logarithms (\ie \(\PPK[\alpha][a = g^\alpha]\)) due to our choice of anonymous credentials whose desirable properties we list in \cref{ZK-anon-cred}.%, which in turn is due to their \ac{PRF} for deriving identifiers from a long-term ID with unlinkability to the original ID but with proof of validity of this derivation. 
%To realize this, we will now introduce such a protocol to enable us to have \ac{DB} anonymous credentials.

We present the protocol in \cref{DB-Schnorr-nbit-figure}.
We will present the protocol as \iac{DB} version of the Schnorr identification 
scheme (\(\PK[\alpha][A = g^\alpha]\)), this is for the sake of exposition.
It can be generalized to \eg CL04~\cite{CLsignatures}.

The (cyclic) group with generator~\(g\) with prime order~\(q\) is a system 
parameter.
The private key~\(\alpha\) with public key~\(A = g^\alpha\) are generated once 
by the prover in the setup phase.
The verifier has a copy of the public key~\(A\) and wants to verify that the 
private key~\(\alpha\) is within a certain distance-bound.

\begin{figure*}
  \centering
  \small
  \setlength{\ProtoArrowLength}{0.07\linewidth}
  \begin{tabular}{p{0.40\linewidth}cp{0.40\linewidth}}
    \(\DBSprove[g, q, \alpha, A = g^\alpha]\):
    & &
    \(\DBSverify[g, q, A]\):
    \\
    \midrule

    \multicolumn{3}{c}{\textbf{Setup}} \\

    \(\rho\rgets \ZZ_q, R\gets g^{\rho}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    % null
    & \(\ProtoSendLeft{c_0, c_1}\)
    & \(c_0\rgets \bin^k, c_1\rgets \bin^k\)
    \\

    \(s_0\gets \rho - c_0\alpha \pmod q\)
    &
    & \(b\rgets \bin\)
    \\

    \(s_1\gets \rho - c_1\alpha \pmod q\)
    &
    & Prepare \(B\in \bin^{|q|+l}\), with \(|q|\) bits set to \(b\) and the 
    remaining \(l\) bits to \(1-b\).
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}: \(\forall i: 0\leq i < |q| + 
        l, j\gets 0\)} \\

%    % null
%    &
%    & Random delay
%    \\

    % null
    & \(\ProtoSendLeft{b_i}\)
    & \(b_i\gets B[i]\)
    \\

    \(r_i\gets s_{b_i}[jb_i + (i-j)(1-b_i)]\)
    & \(\ProtoSendRight{r_i}\)
    & Record \(\Delta t_i\)
    \\

    \(j \gets j + b_i\)
    &
    &
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Construct \(s_b\) as the concatenation of \(r_i\)'s for which \(b_i = 
      b\).
      Accept if \(R = g^{s_b} A^{c_b}\).
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSprove\leftrightarrow \DBSverify\) \ac{DB} Schnorr protocol for \(\PK[\alpha][A = g^\alpha]\).
    The protocol should be repeated \(n\) times to achieve the desired 
    soundness and distance-bounding errors.
  }%
  \label{DB-Schnorr-nbit-figure}
\end{figure*}

During one round, the prover commits to a random nonce: more precisely he 
chooses \(
  \rho\rgets \ZZ_q
\) uniformly at random, computes \(
  R\gets g^\rho
\) and sends \(R\) to the verifier.
The verifier generates two challenges \(
  c_0\rgets \bin^k,
  c_1\rgets \bin^k
\) and sends them to the prover.
The prover computes \(
  s_0\gets \rho - c_0\alpha,
  s_1\gets \rho - c_1\alpha.
\)
This step is the main difference to the original Schnorr protocol: the verifier selects two challenges and the prover computes two responses --- but still only \emph{one nonce}, \(\rho\).
This is also different from the original Brands-Chaum protocol, in which the 
prover and verifier jointly construct \emph{one} challenge with \emph{one} 
response.

We let \(|q|\) denote the length of \(q\) in bits, so any element~\(z\in 
\ZZ_q\) can be represented by \(|q|\) bits.
The verifier will request all \(|q|\) response-bits from one challenge (say 
\(s_b\)) and only \(0 < l\leq |q|\) from the other (\(s_{1-b}\)).
Then the verifier can authenticate the prover by checking if \(
  R = g^{s_b}A^{c_b}.
\)

This must be repeated for \(n\) rounds.


\subsection{Security of the \(l\) bits}

Before we proceed to other security properties, we will address the \(l\)-bit 
problem:
what advantage does the adversary get from those \(l\) leaked bits of the 
second response?

\paragraph*{The unconditional \(l\)-bit problem}

We run the protocol \(n\) times and let the adversary learn \(m+l\) bits of the 
result~\(s_i, s_i'\).
This yields the following equation system:
\begin{align*}
  s_0[0]2^0 + \dotsb + s_0[m-1]2^{m-1} &= r_0 + c\alpha &\pmod q\\
  s_0'[0]2^0 + \dotsb + s_0'[m-1]2^{m-1} &= r_0 + c'\alpha &\pmod q\\
  \vdots \\
  s_{n-1}[0]2^0 + \dotsb + s_{n-1}[m-1]2^{m-1} &= r_{n-1} + c\alpha &\pmod q\\
  s_{n-1}'[0]2^0 + \dotsb + s_{n-1}'[m-1]2^{m-1} &= r_{n-1} + c'\alpha, &\pmod 
  q
\end{align*}
where \(m+l\) of \(s_i[j]\)'s and \(s_i'[j']\)'s for each \(i\) are known by 
the adversary.

\begin{lemma}\label{l-bit-advantage}
  If \[l < m-1+\frac{1}{n}-\frac{f(\lambda)}{n},\] then there are at least 
  \(2^{f(\lambda)}-1\) unique solutions, for some function~\(f\) of the 
  security parameter~\(\lambda\).
\end{lemma}
\begin{proof}
  Consider one instance of the protocol:
  \begin{align*}
    s_i[0]2^0 + \dotsb + s_i[m-1]2^{m-1} &= r_i + c\alpha \\
    s_i'[0]2^0 + \dotsb + s_i'[m-1]2^{m-1} &= r_i + c'\alpha.
  \end{align*}
  This yields \(2m+2\) variables with two equations, thus \(2m\) free variables.
  Let the adversary learn \(m+l\) of the bits, \ie left-hand side \(s_i[j]\)'s or 
  \(s_i'[j']\)'s.
  This leaves \(2m-(m+l) = m-l\) free variables and \(2^{m-l}-1\) possible 
  solutions.

  Repeat this \(n\) times.
  This yields \(n(2m+1)+1\) variables and \(2n\) equations, thus \(2nm+n+1-2n = 
  2mn - n +1 = n(2m-1)+1\) free variables.
  Let the adversary learn \(m+l\) bits in each round, thus \(n(m+l)\) in total.
  This yields \(n(2m-1)+1 -n(m+l) = 2nm-n+1-nm-nl = nm-n+1-nl = n(m-1-l)+1\) 
  free variables and \(2^{n(m-1-l)+1}-1\) unique solutions.
  Consequently, if we want at least \(2^{f(\lambda)}-1\) unique solutions, we 
  have that
  \begin{equation*}
    nm-n-nl+1 > f(\lambda) \iff m-1+\frac{1}{n}-\frac{f(\lambda)}{n} > l.
  \end{equation*}
  Which concludes the proof.
\end{proof}

\paragraph*{The \(l\)-bit problem with commitments}

The adversary has a commitment to the randomness~\(r_i\) in the form of \(R_i = 
g^{r_i}\) and a commitment to \(\alpha\) in the form of \(A = g^\alpha\).
This means that
\begin{align*}
  R = A^{-c'} g^{s'} &= A^{-c'} g^{s'[0] 2^0 + \dotsb + s'[m-1] 2^{m-1}} \\
                     &= A^{-c'} g^{s'[0] 2^0} \dotsb g^{s'[m-1] 2^{m-1}} \\
                     &= A^{-c'} g^{s'_{\text{known}}} g^{s'_{\text{unknown}}}.
\end{align*}
We will now show how the hardness of finding \(s'_{\text{unknown}}\) relates to 
the hardness of finding discrete logarithms.

\begin{definition}[\Acl*{DLP}]
  Let \(g\) be a generator for a group of prime order~\(q\).
  Given \(g, q, A = g^\alpha\), compute \(\alpha\).
\end{definition}

\begin{definition}[DB-Schnorr Problem]%
  \label{DBSP}
  Let \(g\) be a generator for a group of prime order~\(q\).
  Give \(g, q, R = g^\rho A = g^\alpha\) to the adversary.
  Let the adversary choose \(c\) and additionally give him \(\hat s\) such that 
  \(\hat s\) are the \(l\) \emph{least significant} bits of \(s = \rho + 
  c\alpha \pmod q\).
  The adversary wins if he returns \(\hat s'\) such that \(\hat s + \hat s' = s 
  \pmod q\).
\end{definition}

\begin{lemma}\label{DBSPtoDLP}
  Given an algorithm~\(\algA_{\DBS}\) that solves the DB-Schnorr Problem 
  (\cref{DBSP}) with probability \(\epsilon\), we can construct an 
  algorithm \(\algA_{\text{DL}}\) that solves the \ac{DLP} with probability 
  \(\epsilon 2^{-(l+k)}\).
\end{lemma}

\begin{proof}
  We will now construct the algorithm \(\algA_{\text{DL}}\) given the algorithm 
  \(\algA_{\DBS}\) and the \ac{DLP} challenge \(g, q, A_{\text{DL}}\).
  Assume that \(\algA_{\DBS}\) succeeds with probability \(\epsilon\).

  We proceed as follows.
  Guess \(c\rgets \ZZ_k\), choose \(\hat s\rgets \ZZ_{2^l}\).
  Let \(\hat R\gets A_{\DBS}^c A_{\text{DL}} g^{\hat s}\) and give
  \(\hat R\) to \(\algA_{\DBS}\).
  If \(c'\gets \algA_{\DBS}(g, q, A_{\DBS}, \hat R)\) returns \(c'\neq c\), 
  abort.
  The probability of success is \(2^{-k}\).
  Otherwise, give \(\hat s\) to \(\algA_{\DBS}\).
  Now, by construction, we have that \(
    \hat R = A_{\DBS}^c g^{\hat s} A_{\text{DL}}.
  \)

  If \(A_{\text{DL}} = g^{\alpha_{\text{DL}}}\) is chosen such that 
  \(\alpha_{\text{DL}}\) has the \(l\) least significant bits set to zero 
  (probability \(2^{-l}\)), then will have \(
    \alpha_{\text{DL}}\gets \algA_{\DBS}(g, q, A_{\DBS}, \hat R, \hat s)
  \) with probability \(\epsilon\).
  Thus, the total probability of success is \(
    \epsilon 2^{-l} 2^{-k} = \epsilon 2^{-(l+k)}.
  \)
\end{proof}

As mentioned above, both \(l\) and \(k\) are logarithmic in the security 
parameter.

\subsection{\Acl*{ZK} and \acl*{PK}}\label{nbit-ZKPK}

The main difference between this protocol and the Schnorr protocol is that we 
have the prover compute responses for two different challenges, \(c_0, c_1\).
In the authentication step, the verifier chooses only one of those challenges.
However, the verifier requests all \(|q|\) bits of \(s_b\) and \(l\) bits of 
\(s_{1-b}\).

This is \iacl{PK}:
Completeness and soundness follows from the Schnorr protocol.
The knowledge extractor works exactly the same.
It does not matter that the verifier first chooses two challenges and later 
reveals which one to use and the prover sends the response bit-by-bit.

This is \emph{computational} \acl{ZK}:
The simulator chooses \[
  s_0, s_1\rgets \ZZ_q; \quad
  c_0, c_1\rgets \bin^k; \quad
  b\rgets \bin.
\]
Then it can set \[
  R_0\gets g^{s_0} A^{c_0}, \quad
  R_1\gets g^{s_1} A^{c_1}.
\]
Now the simulator must come up with those \(l\) bits.
\Cref{l-bit-advantage,DBSPtoDLP} say that distinguishing these bits from random 
is as hard as the \ac{DLP}.
So, the simulator can simply choose the \(l\) bits~\(L\rgets \bin^l\) uniformly 
at random.

The simulator outputs \(R_b, c_0, c_1, s_b, L\).

%Therefore the standard proof for Schnorr as a malicious-verifier \ac{ZKPK} 
%protocol with soundness error \(2^{-k n}\) still 
%holds~\cite[\eg][]{OnSigmaProtocols}.
%(We note that \(l\), which is also the length of the challenge bit string, must 
%be logarithmic in the security parameter, \(\lambda\), for a malicious 
%verifier.)

\subsection{\acs*{DBMF}, \acs*{DBTF} and \acs*{DBDH} resistance}

\paragraph{\Acl{DBMF}}

In \ac{DBMF}, the adversary will try to authenticate to a verifier by querying 
a far-away prover.
By \cref{TaintedMF}, pure relaying will be detected by the verifier.
So the adversary must resort to things like querying in advance \etc.

\begin{theorem}[\acs*{DBMF} resistance]
  Let \(\adv\) be a \((t, \qobs, \qp, \qv)\)-MF adversary, then \(
    \Adv_{\DBS}^{\text{MF}}(\adv) =
      \left(\frac{1}{2} + \frac{1}{2^{|q|-l}}\right)^n,
  \) where \(m, q\) are as in \cref{DB-Schnorr-nbit}.
\end{theorem}

\begin{proof}
  It follows from the \ac{ZK} property (\cref{nbit-ZKPK}) that the adversary 
  cannot learn anything by observation.
  This leaves the adversary with the following:
  \begin{enumerate}
    \item guess which challenge the verifier will use and request the correct 
      response from the prover, receiving the challenge first would taint the 
      session (\cref{TaintedMF});
    \item guess the second response.
  \end{enumerate}

  The first case yields success with probability \(\frac{1}{2}\), since the 
  choice is uniformly distributed over the two challenges.
  The adversary requests all \(|q|\) bits of the response~\(s_{\hat b}\) and 
  \(l\) bits of \(s_{1-\hat b}\).
  When the verifier sends challenge bit \(b_i = \hat b\), the adversary replies 
  with a bit from \(s_{\hat b}\).
  If \(b_i = 1-\hat b\), then the adversary uses the \(l\) bits.

  If the adversary guessed \(\hat b = b\) correctly, then the verifier will 
  accept.
  Otherwise, the adversary must compute the remaining \(|q|-l\) bits of 
  \(s_{1-\hat b}\).

  Guessing the remaining bits yield a success probability of 
  \(\frac{1}{2^{|q|-l}}\).
  \Cref{DBSPtoDLP} states that any algorithm that can compute the remaining 
  bits can also solve a corresponding \ac{DLP}.
  It follows that the adversary cannot do non-negligibly better than guessing 
  the remaining bits.

  Thus, the success probability is \(\frac{1}{2}+\frac{1}{2^{|q|-l}}\) per 
  round, or \(\left(\frac{1}{2}+\frac{1}{2^{|q|-l}}\right)^n\) in total.
\end{proof}

\paragraph{\Acl{DBTF}}

We cannot achieve \ac{DBTF} resistance.
Indeed, the prover can send \(l+\nu\) bits of both response strings, \(s_0\) 
and \(s_1\), to the adversary.
When the adversary receives the \(l+1\)th bit, he learns \(b\).
He can send \(b\) to the prover and answer correctly to the verifier, provided 
\(\nu \geq 1\).
By the time he receives the next challenge from the verifier, the prover will 
have sent him the remaining bits of \(s_b\) without revealing more bits about 
\(s_{1-b}\).
This would not taint the session.
As long as \(l+\nu\) is sufficiently small, the adversary cannot compute the 
remaining bits of \(s_{1-b}\) to compute the prover's secret.

\paragraph{\Acl{DBDH}}

The protocol is also secure against distance hijacking due to the fact that the 
authenticating bit string is used during the \ac{DB} phase.
(Brands-Chaum used the challenge bit string, something that made their protocol 
vulnerable.)
\Ac{DBDH} requires that the adversary finds a collision between his response 
and that of the honest prover.
Thus the probability of success is equivalent to a collision for the responses 
for the chosen challenge --- in each round.

\begin{theorem}[\acs*{DBDH}/\acs*{DBDF} resistance]
  Let \(\adv\) be a \((t, \qobs, \qp, \qv)\)-DH adversary, then 
  \(\Adv_{DBS}^{\text{DH}}(\adv) = \frac{1}{2^n}\).
\end{theorem}

\begin{proof}
  The honest prover will choose \(\rho\) such that \(R = g^\rho\).
  The adversary can send his own \(R' = g^{\rho'}\) to the verifier, or let 
  \(R' = R\) to not interfere.

  The verifier will choose \(c_0, \dotsc, c_1\).
  The honest prover will compute \(s_i = \rho - c_i \alpha\), where \(\alpha\) 
  is his secret.
  If the adversary chose \(R' = g^{\rho'}\), he can compute \(s_i' = \rho' - 
  c_i \alpha'\), where \(\alpha'\) is the adversary's secret.
  If the adversary didn't choose \(R'\), he can only guess the values for 
  \(s_i'\).

  During the fast phase, the adversary has two options:
  for each challenge bit, the adversary can \(\Commit\) to a response bit or to 
  \(\Prompt\) the honest prover to send a bit.

  If the adversary chose \(R'\), then he knows \(\rho'\) and can compute the 
  correct \(s_i' = \rho' - c_i \alpha'\) for \(i\in \bin\).
  If the adversary \(\Commit\)s:
  Now, the adversary must commit to one bit of \(s_0'\) or \(s_1'\) before 
  seeing the verifier's choice \(b_i\).
  He can make a guess~\(\hat b\) at the verifier's choice~\(b\).
  Then he commits to the next bit of \(s_{\hat b}'\).
  If the challenge~\(b_i \neq \hat b\), he will commit to the same bit for the 
  next round.
  If indeed \(\hat b = b\), the verifier will accept.
  The success probability is \(\frac{1}{2}\) over all bits.

  If the adversary \(\Prompt\)s:
  The prover computed \(s_0\) and \(s_1\) using \(\rho\) and \(\alpha\).
  However, the verifier will use \(R'\) and \(A'\) in the verification step.
  This will succeed if \(s_b = s_b'\), the probability of which is 
  \(\frac{1}{q}\).
  This means that the probability of success for prompting a bit is 
  \(\frac{1}{2}\), or \(\frac{1}{2^{|q|}}\) over all bits.

  If the adversary didn't choose \(R'\) he consequently doesn't know \(\rho\) 
  and cannot compute the correct \(s_0\) and \(s_1\).
  Thus, committing yields \(\frac{1}{2}\) probability per bit.
  The same applies for prompting.

  Obviously, the better strategy for the adversary is to choose \(R' = 
  g^{\rho'}\).
  It's also a better strategy to \(\Commit\) (\ac{DBDF}) rather than 
  \(\Prompt\) (\ac{DBDH}).
  We thus have that
  \(\Adv_{\DBS}^{\text{DH}}(\adv) = \frac{1}{2^n}\) for \(n\) rounds,
  which concludes the proof.
\end{proof}

