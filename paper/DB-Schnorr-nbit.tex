\section{Bit-by-bit distance-bounding Schnorr protocol}%
\label{DB-Schnorr-nbit}

We will now continue with a more traditional (in \ac{DB} terms) version of the 
protocol, one that uses bit-by-bit communication.
As mentioned in \cref{related-work}, while there exists a \iac{PPK} 
protocol~\cite{ProProx}, there is none for discrete logarithms. We will now introduce such a protocol to enable us to have \ac{DB} anonymous credentials.

%One protocol exists in the literature that provides \acp{PPK} with most of the desired properties described previously, ProProx~\cite{ProProx}\footnote{Note that~\cite{ProProx} uses the abbreviation PoPoK, we prefer \acs{PPK} for shorter notation.}.
%ProProx is secure against a malicious verifier, but it provides \iac{PPK} protocol for quadratic residues (\ie protocols of the form \(\PPK[\alpha][a = 
%  \alpha^2]\)), while in our context, we need \iac{PPK} protocol for discrete logarithms (\ie \(\PPK[\alpha][a = g^\alpha]\)) due to our choice of anonymous credentials whose desirable properties we list in \cref{ZK-anon-cred}.%, which in turn is due to their \ac{PRF} for deriving identifiers from a long-term ID with unlinkability to the original ID but with proof of validity of this derivation. 
%To realize this, we will now introduce such a protocol to enable us to have \ac{DB} anonymous credentials.

We present the protocol in \cref{DB-Schnorr-nbit-figure}.
We will present the protocol as \iac{DB} version of the Schnorr identification 
scheme (\(\PK[\alpha][A = g^\alpha]\)), this is for the sake of exposition.
It can be generalized to \eg CL04~\cite{CLsignatures}.

The (cyclic) group with generator~\(g\) with prime order~\(q\) is a system 
parameter.
The private key~\(\alpha\) with public key~\(A = g^\alpha\) are generated once 
by the prover in the setup phase.
The verifier has a copy of the public key~\(A\) and wants to verify that the 
private key~\(\alpha\) is within a certain distance-bound.

\begin{figure*}
  \centering
  \small
  \setlength{\ProtoArrowLength}{0.07\linewidth}
  \begin{tabular}{p{0.40\linewidth}cp{0.40\linewidth}}
    \(\DBSprove[g, q, \alpha, A = g^\alpha]\):
    & &
    \(\DBSverify[g, q, A]\):
    \\
    \midrule

    \multicolumn{3}{c}{\textbf{Setup}} \\

    \(\rho\rgets \ZZ_q, R\gets g^{\rho}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    % null
    & \(\ProtoSendLeft{c_0, c_1}\)
    & \(c_0\rgets \bin^k, c_1\rgets \bin^k\)
    \\

    \(s_0\gets \rho - c_0\alpha \pmod q\)
    &
    & \(b\rgets \bin\)
    \\

    \(s_1\gets \rho - c_1\alpha \pmod q\)
    &
    & Prepare \(B\in \bin^{|q|+l}\), with \(|q|\) bits set to \(b\) and the 
    remaining \(l\) bits to \(1-b\).
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}: \(\forall i: 0\leq i < |q| + 
        l, j\gets 0\)} \\

%    % null
%    &
%    & Random delay
%    \\

    % null
    & \(\ProtoSendLeft{b_i}\)
    & \(b_i\gets B[i]\)
    \\

    \(r_i\gets s_{b_i}[jb_i + (i-j)(1-b_i)]\)
    & \(\ProtoSendRight{r_i}\)
    & Record \(\Delta t_i\)
    \\

    \(j \gets j + b_i\)
    &
    &
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Construct \(s_b\) as the concatenation of \(r_i\)'s for which \(b_i = 
      b\).
      Accept if \(R = g^{s_b} A^{c_b}\).
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSprove\leftrightarrow \DBSverify\) \ac{DB} Schnorr protocol for \(\PK[\alpha][A = g^\alpha]\).
    The protocol should be repeated \(n\) times to achieve the desired 
    soundness and distance-bounding errors.
  }%
  \label{DB-Schnorr-nbit-figure}
\end{figure*}

During one round, the prover commits to a random nonce: more precisely he 
chooses \(
  \rho\rgets \ZZ_q
\) uniformly at random, computes \(
  R\gets g^\rho
\) and sends \(R\) to the verifier.
The verifier generates two challenges \(
  c_0\rgets \bin^k,
  c_1\rgets \bin^k
\) and sends them to the prover.
The prover computes \(
  s_0\gets \rho - c_0\alpha,
  s_1\gets \rho - c_1\alpha.
\)
This step is the main difference to the original Schnorr protocol: the verifier selects two challenges and the prover computes two responses --- but still only \emph{one nonce}, \(\rho\).
This is also different from the original Brands-Chaum protocol, in which the 
prover and verifier jointly construct \emph{one} challenge with \emph{one} 
response.

We let \(|q|\) denote the length of \(q\) in bits, so any element~\(z\in 
\ZZ_q\) can be represented by \(|q|\) bits.
The verifier will request all \(|q|\) response-bits from one challenge (say 
\(s_b\)) and only \(0 < l\leq |q|\) from the other (\(s_{1-b}\)).
Then the verifier can authenticate the prover by checking if \(
  R = g^{s_b}A^{c_b}.
\)

This must be repeated for \(n\) rounds.

\subsection{Security analysis}

We can prove this protocol secure against \ac{DBMF}, \ac{DBDH} and \ac{DBDF}; 
but not against \ac{DBTF}.
Those proofs are available in the full version of the paper.
Here, we will discuss only the most crucial differences.

\paragraph*{The \(l\)-bit problem}

We can show that the system of linear equations created by the protocol and 
consisting of leaked bits from the second reply is underdetermined.
However, we cannot get information theoretic security, that would require 
leaking no bits, but we leak some bits.
The only lead an adversary get to those remaining unknown bits are the 
commitments.
The adversary has a commitment to the randomness~\(r_i\) in the form of \(R_i = 
g^{r_i}\) and a commitment to \(\alpha\) in the form of \(A = g^\alpha\).
This means that
\begin{align*}
  R = A^{-c'} g^{s'} &= A^{-c'} g^{s'[0] 2^0 + \dotsb + s'[m-1] 2^{m-1}} \\
                     &= A^{-c'} g^{s'[0] 2^0} \dotsb g^{s'[m-1] 2^{m-1}} \\
                     &= A^{-c'} g^{s'_{\text{known}}} g^{s'_{\text{unknown}}}.
\end{align*}
We will now show how the hardness of finding \(s'_{\text{unknown}}\) relates to 
the hardness of finding discrete logarithms.

\begin{definition}[\Acl*{DLP}]
  Let \(g\) be a generator for a group of prime order~\(q\).
  Given \(g, q, A = g^\alpha\), compute \(\alpha\).
\end{definition}

\begin{definition}[DB-Schnorr Problem]%
  \label{DBSP}
  Let \(g\) be a generator for a group of prime order~\(q\).
  Give \(g, q, R = g^\rho A = g^\alpha\) to the adversary.
  Let the adversary choose \(c\) and additionally give him \(\hat s\) such that 
  \(\hat s\) are the \(l\) \emph{least significant} bits of \(s = \rho + 
  c\alpha \pmod q\).
  The adversary wins if he returns \(\hat s'\) such that \(\hat s + \hat s' = s 
  \pmod q\).
\end{definition}

\begin{lemma}\label{DBSPtoDLP}
  Given an algorithm~\(\algA_{\DBS}\) that solves the DB-Schnorr Problem 
  (\cref{DBSP}) with probability \(\epsilon\), we can construct an 
  algorithm \(\algA_{\text{DL}}\) that solves the \ac{DLP} with probability 
  \(\epsilon 2^{-(l+k)}\).
\end{lemma}

The proof of this lemma can be found in the full version of the paper.

\paragraph*{\Acl*{ZK} and \acl*{PK}}\label{nbit-ZKPK}

The main difference between this protocol and the Schnorr protocol is that we 
have the prover compute responses for two different challenges, \(c_0, c_1\).
In the authentication step, the verifier chooses only one of those challenges.
However, the verifier requests all \(|q|\) bits of \(s_b\) and \(l\) bits of 
\(s_{1-b}\).

This is \iacl{PK}:
Completeness and soundness follows from the Schnorr protocol.
The knowledge extractor works exactly the same.
It does not matter that the verifier first chooses two challenges and later 
reveals which one to use and the prover sends the response bit-by-bit.

The change is with the \acl{ZK} property.
This is \emph{computational} \acl{ZK}:
The simulator chooses \[
  s_0, s_1\rgets \ZZ_q; \quad
  c_0, c_1\rgets \bin^k; \quad
  b\rgets \bin.
\]
Then it can set \[
  R_0\gets g^{s_0} A^{c_0}, \quad
  R_1\gets g^{s_1} A^{c_1}.
\]
Now the simulator must come up with those \(l\) bits.
By \cref{DBSPtoDLP} and some lemmas in the full version of the paper, we can 
see that distinguishing these bits from random is comparable to solving the 
\ac{DLP}.
So, the simulator can simply choose the \(l\) bits~\(L\rgets \bin^l\) uniformly 
at random.

The simulator outputs \(R_b, c_0, c_1, s_b, L\).

\paragraph*{Why not \acs*{DBTF}?}

The problem is that asymptotically, \(l\) and \(l+1\) are rather close.
So the colluding parties can exchange \(l+1\) bits instead of just \(l\).
This way they can create a buffer of responses.
However, this means that they can stretch the distance bound; at some point, 
\(l+\epsilon\) will be too large and make \(\alpha\) easy enough to guess.
So the incentive changes from the legitimate party not wanting to cheat, into 
the legitimate party not wanting to cheat \enquote{too much}.
However, we have not formally treated this part more than concluding that we 
cannot prove \ac{DBTF} resistance in terms of \cref{TaintedTF,TFresistance}.
