\subsection{Anonymous credentials}%
\label{ZK-anon-cred}

%For an anonymous credential system (\(\ACscheme\)), it is sufficient to have a 
%commitment scheme (\(\ACcommit\)), a signature scheme and (efficient) protocols 
%for
%\begin{enumerate*}
%  \item proving equality of two committed values (\(\ACeq\));
%  \item getting a signature on a committed value (\(\ACreq, \ACissue\)); and
%  \item proving knowledge of a signature on a committed value 
%    (\(\ACprove\))~\cite{CLsignatures}.
%\end{enumerate*}

\NewScheme{\AC}{AC}

We need an anonymous credential system, \(\AC\), which provides the following algorithms and properties.

\NewAlgorithm{\ACcommit}{\AC.\!Commit}

\(\AC\) must provide a commitment scheme, \(\ACcommit\), and algorithms such that the prover can convince a verifier that he knows the commitment, which means that:
\begin{equation*}
  \PK[k, o][c = \ACcommit[k,o]].
\end{equation*}
%and that two commitments are commitments to the same value:
%\begin{multline*}
%  \mleftright
%  \PK\left\{ \left(k, o, o'\right) : \right. \\
%    \left. c = \ACcommit[k,o]\land c' = \ACcommit[k,o'] \right\}.
%\end{multline*}
% XXX Review requirements of AC.commit
We will require the commitment scheme to be \emph{perfectly hiding} and computationally binding, rather than the other way around.
Indeed, we are more concerned with long-term privacy, which means that we are looking for information-theoretic security with respect to confidentiality.

\NewAlgorithm{\ACsign}{\AC.\!Sign}
\NewAlgorithm{\ACblind}{\AC.\!BlindSig}
\NewAlgorithm{\ACverifySig}{\AC.\!VerifySig}
\NewAlgorithm{\ACgetSig}{\AC.\!GetSig}
\NewAlgorithm{\ACissueSig}{\AC.\!IssueSig}
\NewAlgorithm{\ACproveSig}{\AC.\!ProveSig}

\(\AC\) must also contain a (blindable) signature scheme with the associated protocols enabling one to get a signature on a committed value (\(\ACgetSig\leftrightarrow \ACissueSig\)) and to prove knowledge of a signature on a committed value (\(\ACproveSig\leftrightarrow \ACverifySig\)).

The prover commits to a value \(k\) with commitment \(c\gets \ACcommit[k, o]\) and opening \(o\).
Afterwards, he uses \(\sigma\gets \ACgetSig\leftrightarrow \ACissueSig\) to obtain a signature \(\sigma = \ACsign[_{sk}][k]\) on the value \(k\), in which \(sk\) is the signing key of the signer.

At a later point, the prover wants to prove to a verifier that he knows \(k\) and a signature \(\sigma\) on \(k\) made by the owner of \(pk\) (corresponding to \(sk\)) without revealing \(k\) nor \(\sigma\) (\ie, in a zero-knowledge manner).
The prover and verifier will run the protocol \(\ACproveSig\leftrightarrow \ACverifySig\) to prove the following:
\begin{equation*}
  \PK[k][\sigma' = \ACblind[\ACsign[_{sk}][k]]].
\end{equation*}

\NewAlgorithm{\ACprf}{\AC.\!PRF}
\NewAlgorithm{\ACprovePRF}{\AC.\!ProvePRF}
\NewAlgorithm{\ACverifyPRF}{\AC.\!VerifyPRF}

Finally, we need \iac{PRF}, \(\ACprf\), such that there exists a protocol \(\ACprovePRF\leftrightarrow \ACverifyPRF\) implementing the following 
\ac{PK}:
\begin{equation*}
  \PK[k][y = \ACprf[_k][x]].
\end{equation*}
This means that the prover can convince the verifier that \(y = \ACprf[_k][x]\) without revealing \(k\).


\emph{Possible instantiations.}
The \(\AC\) scheme can be instantiated using the Pedersen commitment~\cite{PedersenCommitment} for \(\ACcommit\),
CL-signatures~\cite{CLsignatures} (or adapted CL-signatures as in~\cite{AnonPass}) for \(\ACsign, \ACblind, \ACgetSig, \ACissueSig\) and the \ac{VRF} by \citet{DY-VRF} as \(\ACprf\).
These are used together in Anon-Pass~\cite{AnonPass} and by~\citet{HowToWinTheCloneWars} to form unclonable anonymous credentials for subscriptions. 
We use their mechanisms but change the basis of the authentication window (epoch) from a time interval to a protest (cause).
However, we will modify the \ac{ZKPK} protocols slightly, by making them \acl{DB}.
