\subsection{Anonymous credentials}%
\label{ZK-anon-cred}

%For an anonymous credential system (\(\ACscheme\)), it is sufficient to have a 
%commitment scheme (\(\ACcommit\)), a signature scheme and (efficient) protocols 
%for
%\begin{enumerate*}
%  \item proving equality of two committed values (\(\ACeq\));
%  \item getting a signature on a committed value (\(\ACreq, \ACissue\)); and
%  \item proving knowledge of a signature on a committed value 
%    (\(\ACprove\))~\cite{CLsignatures}.
%\end{enumerate*}

\NewCryptoScheme{\AC}{AC}

We need an anonymous credential system, \(\AC\), which provides the following 
algorithms and properties.

\NewAlgorithm{\ACcommit}{\AC.\!Commit}

\(\AC\) must provide a commitment scheme, \(\ACcommit\), and algorithms such 
that the prover can convince a verifier that he knows the commitment, i.e.
\begin{equation*}
  \PK[k, o][c = \ACcommit[k,o]].
\end{equation*}
%and that two commitments are commitments to the same value:
%\begin{multline*}
%  \mleftright
%  \PK\left\{ \left(k, o, o'\right) : \right. \\
%    \left. c = \ACcommit[k,o]\land c' = \ACcommit[k,o'] \right\}.
%\end{multline*}
% XXX Review requirements of AC.commit
We prefer that the commitment scheme is \emph{perfectly hiding} and 
computationally binding, rather than the other way\footnote{%
  We are more concerned with long-term privacy, thus information-theoretic 
  hiding.
}.

\NewAlgorithm{\ACsign}{\AC.\!Sign}
\NewAlgorithm{\ACblind}{\AC.\!BlindSig}
\NewAlgorithm{\ACverifySig}{\AC.\!VerifySig}
\NewAlgorithm{\ACgetSig}{\AC.\!GetSig}
\NewAlgorithm{\ACissueSig}{\AC.\!IssueSig}
\NewAlgorithm{\ACproveSig}{\AC.\!ProveSig}

\(\AC\) must also provide a (blindable) signature scheme with protocols to get a 
signature on a committed value (\(\ACgetSig\leftrightarrow \ACissueSig\)) and to 
prove knowledge of a signature on a committed value 
(\(\ACproveSig\leftrightarrow \ACverifySig\)).

The prover commits to a value \(k\) with commitment \(c\gets \ACcommit[k, o]\) 
and opening \(o\).
Then he uses \(\sigma\gets \ACgetSig\leftrightarrow \ACissueSig\) to obtain a 
signature \(\sigma = \ACsign[k][_{sk}]\) on the value \(k\), where \(sk\) is the 
signing key of the signer.

At a later point, the prover wants to prove to a verifier that he knows \(k\) 
and a signature \(\sigma\) on \(k\) made by the owner of \(pk\) (corresponding 
to \(sk\)), i.e.\ without revealing \(k\) nor \(\sigma\).
The prover and verifier will run the protocol \(\ACproveSig\leftrightarrow 
  \ACverifySig\) to prove the following:
\begin{equation*}
  \PK[k][\sigma' = \ACblind[\ACsign[k][_{sk}]]].
\end{equation*}

\NewAlgorithm{\ACprf}{\AC.\!PRF}
\NewAlgorithm{\ACprovePRF}{\AC.\!ProvePRF}
\NewAlgorithm{\ACverifyPRF}{\AC.\!VerifyPRF}

Finally we need \iac{PRF}, \(\ACprf\), such that there exists a protocol 
\(\ACprovePRF\leftrightarrow \ACverifyPRF\) which implements the following 
\ac{PK}:
\begin{equation*}
  \PK[k][y = \ACprf[x][_k]],
\end{equation*}
i.e.\ that the prover can convince the verifier that \(y = \ACprf[x][_k]\) 
without revealing \(k\).

% XXX Replace \PRF
\NewFunction{\PRF}{PRF}


\subsubsection{Instantiations of the anonymous credentials} 

The \(\AC\) scheme can be instantiated using the Pedersen 
commitment~\cite{PedersenCommitment} for \(\ACcommit\),
CL-signatures~\cite{CLsignatures} (or adapted CL-signatures as 
in~\cite{AnonPass}) for \(\ACsign, \ACblind, \ACgetSig, \ACissueSig\) and
the \ac{VRF} by \citet{DY-VRF} as \(\ACprf\).
These are used together in e.g.\ Anon-Pass~\cite{AnonPass} and by 
\citet{HowToWinTheCloneWars} to form unclonable anonymous credentials for 
subscriptions.
We will, however, modify the \ac{ZKPK} protocols slightly, by making them 
\acl{DB}.
