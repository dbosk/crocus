\subsection{Anonymous credentials}%
\label{ZK-anon-cred}

%For an anonymous credential system (\(\ACscheme\)), it is sufficient to have a 
%commitment scheme (\(\ACcommit\)), a signature scheme and (efficient) protocols 
%for
%\begin{enumerate*}
%  \item proving equality of two committed values (\(\ACeq\));
%  \item getting a signature on a committed value (\(\ACreq, \ACissue\)); and
%  \item proving knowledge of a signature on a committed value 
%    (\(\ACprove\))~\cite{CLsignatures}.
%\end{enumerate*}


We need an anonymous credential system, \(\AC\), which provides the following algorithms and properties.


\(\AC\) must provide a commitment scheme, \(\ACcommit\), and algorithms such that the prover can convince a verifier that he knows the commitment, which means that:
\begin{equation*}
  \PK[k, o][c = \ACcommit[k,o]].
\end{equation*}
%and that two commitments are commitments to the same value:
%\begin{multline*}
%  \mleftright
%  \PK\left\{ \left(k, o, o'\right) : \right. \\
%    \left. c = \ACcommit[k,o]\land c' = \ACcommit[k,o'] \right\}.
%\end{multline*}
% XXX Review requirements of AC.commit
We require the commitment scheme to be \emph{perfectly hiding} and computationally binding, rather than the other way around.
Indeed, we are more concerned with long-term privacy, which means that we are looking for information-theoretic security with respect to confidentiality.
\(\ACcommit\) can be instantiated with the Pedersen commitment 
scheme~\cite{PedersenCommitment}, see \cref{ACcommitAlg}.

\begin{figure}
  \small
  \begin{algorithmic}
    \Function{\ACcommit}{$x, r$}
    \State \Return $(g^x h^r, r)$
    \EndFunction
  \end{algorithmic}
  \caption{\label{ACcommitAlg}%
    Pedersen's commitment scheme~\cite{PedersenCommitment}.
    Let \(G = \gen{g} = \gen{h}\) be a group with prime order \(q\) and 
    generators \(g\) and \(h\).%
    The \(r\) should be chosen randomly from \(\ZZ_q\).
  }
\end{figure}

\(\AC\) must also contain a (blindable) signature scheme with the associated protocols enabling one to get a signature on a committed value (\(\ACgetSig\leftrightarrow \ACissueSig\)) and to prove knowledge of a signature on a committed value (\(\ACproveSig\leftrightarrow \ACverifySig\)).
This can be instantiated using CL-signatures~\cite{CLsignatures}, see 
\cref{ACsignAlg,ACacAlg}.

\begin{figure}
  \small
  \begin{algorithmic}
    \Function{\ACsetup}{}
    \State $x\rgets \ZZ_q, X\gets g^x, y\rgets \ZZ_q, Y\gets g^y, z\rgets 
    \ZZ_q, Z\gets g^z$
    \State $\sk\gets (x,y,z), \pk\gets (q, G, G_T, g, g_T, e, X, Y, Z)$
    \State \Return $(\sk, \pk)$
    \EndFunction

    \Function{\ACsign}{$m, r, \pk, \sk$}
    \State $a\rgets G, A\gets a^z$
    \State $b\gets a^y, B\gets A^y$
    \State $c\gets a^{x+xym} A^{xyr}$
    \State \Return $\sigma = (a, A, b, B, c)$
    \EndFunction

    \Function{\ACblind}{$\sigma = (a, A, b, B, c)$}
    \State $r\rgets \ZZ_q, r'\rgets \ZZ_q$
    \State $\tilde a\gets a^r, \tilde A\gets A^r,
      \tilde b\gets b^r, \tilde B\gets B^r,
      \hat c\gets (c^r)^{r'}$
    \State \Return $\tilde \sigma = (\tilde a, \tilde A,
      \tilde b, \tilde B, \hat c)$
    \EndFunction

    \Function{\ACverifySig}{$m, r, \sigma = (a, A, b, B, c)$}
    \If{$e(a, Z) \neq e(g, A)$}
    \State \Return $\bot$
    \Comment $A$ malformed
    \ElsIf{$e(a, Y) \neq e(g, b) \lor e(A, Y) \neq e(g, B)$}
    \State \Return $\bot$
    \Comment $b$ or $B$ malformed
    \ElsIf{$e(X, a)\cdot e(X, b)^m \cdot e(X, B)^r \neq e(g, c)$}
    \State \Return $\bot$
    \Comment $c$ malformed
    \EndIf
    \State \Return $\top$
    \EndFunction

  \end{algorithmic}
  \caption{\label{ACsignAlg}%
    The CL-signature scheme~\cite{CLsignatures}.
    Let \(G = \gen{g}, G_T = \gen{g_T}\) be groups of prime order \(q\).
    Let \(e\colon G\to G_T\) be a bilinear map.
  }
\end{figure}

\begin{figure}
  \centering
  \small
  \begin{tabular}{lcl}
    \(\ACgetSig[\pk, m]\)
    &
    & \(\ACissueSig[\pk, \sk]\)

    \\\toprule

    \(r\rgets \ZZ_q\)
    &
    &

    \\

    \(M\gets \ACcommit[m, r]\)
    & \smash{\(\ProtoSendRight[3em]{M}\)}
    &

    \\\\

    \multicolumn{3}{c}{\(\PK[m, r][M = \ACcommit[m, r]]\)}

    \\\\

    % null
    &
    & \(\alpha\rgets\)
    
    \\
    
    % null
    &
    & \(\ZZ_q, a\gets g^\alpha, A\gets a^z\)

    \\

    % null
    &
    & \(b\gets a^y, B\gets A^y\)

    \\

    \(\sigma\gets (a, A, b, B, c)\)
    & \smash{\(\ProtoSendLeft[3em]{\mathclap{(a, A, b, B, c)}}\)}
    & \(c\gets a^x M^{\alpha x y}\)

    \\\bottomrule

    \\

    \(\ACproveSig[\pk, \sigma, m, r]\)
    &
    & \(\ACverifySig[\pk, \sk]\)

    \\\toprule

    \(\tilde \sigma\gets \ACblind[\sigma]\)
    & \smash{\(\ProtoSendRight[3em]{\tilde \sigma}\)}
    & \(e(\tilde a, Z) \stackrel?= e(g, \tilde A)\)

    \\

    % null
    &
    & \(e(\tilde a, Y) \stackrel?= e(g,b)\)

    \\

    % null
    &
    & \(e(\tilde A, Y) \stackrel?= e(g, \tilde B)\)

    \\

    \(v_x\gets e(X, \tilde a)\)
    &
    & \(v_x\gets e(X, \tilde a)\)

    \\

    \(v_{xy}\gets e(X, \tilde b)\)
    &
    & \(v_{xy}\gets e(X, \tilde b)\)

    \\

    %\(V_{xy}\gets e(X, \tilde B), v_s\gets e(g, \hat c)\)
    \(v_s\gets e(g, \hat c)\)
    &
    %& \(V_{xy}\gets e(X, \tilde B), v_s\gets e(g, \hat c)\)
    & \(v_s\gets e(g, \hat c)\)

    \\\\

    \multicolumn{3}{c}{\(\PK[m,r][v_s^r = v_x v_{xy}^m]\)}

    \\\bottomrule
  \end{tabular}
  \caption{\label{ACacAlg}%
    Protocols for CL anonymous credentials~\cite{CLsignatures}.
    Let \(G = \gen{g}, G_T = \gen{g_T}\) be groups of prime order \(q\).
    Let \(e\colon G\to G_T\) be a bilinear map.
  }
\end{figure}

The prover commits to a value \(k\) with commitment \(c\gets \ACcommit[k, o]\) and opening \(o\).
Afterwards, he uses \(\sigma\gets \ACgetSig\leftrightarrow \ACissueSig\) to obtain a signature \(\sigma = \ACsign[_{sk}][k]\) on the value \(k\), in which \(sk\) is the signing key of the signer.

At a later point, the prover wants to prove to a verifier that he knows \(k\) and a signature \(\sigma\) on \(k\) made by the owner of \(pk\) (corresponding to \(sk\)) without revealing \(k\) nor \(\sigma\) (\ie, in a zero-knowledge manner).
The prover and verifier run the protocol \(\ACproveSig\leftrightarrow \ACverifySig\) to prove the following:
\begin{equation*}
  \PK[k][\sigma' = \ACblind[\ACsign[_{sk}][k]]].
\end{equation*}


Finally, we need \iac{PRF}, \(\ACprf\), such that there exists a protocol \(\ACprovePRF\leftrightarrow \ACverifyPRF\) implementing the following 
\ac{PK}:
\begin{equation*}
  \PK[k][y = \ACprf[_k][x]].
\end{equation*}
This means that the prover can convince the verifier that \(y = \ACprf[_k][x]\) without revealing \(k\).


\emph{Possible instantiations.}
The \(\AC\) scheme can be instantiated using the Pedersen commitment~\cite{PedersenCommitment} for \(\ACcommit\),
CL-signatures~\cite{CLsignatures} (or adapted CL-signatures as in~\cite{AnonPass}) for \(\ACsign, \ACblind, \ACgetSig, \ACissueSig\) and the \ac{VRF} by \citet{DY-VRF} as \(\ACprf\).
These are used together in Anon-Pass~\cite{AnonPass} and by 
\textcite{HowToWinTheCloneWars} to form unclonable anonymous credentials for 
subscriptions.
We use their mechanisms but change the basis of the authentication window 
(epoch) from a time interval to a protest (cause).
However, we will use our \ac{DB} version of the Schnorr protocol 
(\cref{DBSchnorr}) for the \ac{ZKPK} protocols.
