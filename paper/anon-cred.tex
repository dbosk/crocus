\subsection{Anonymous credentials}%
\label{ZK-anon-cred}

The anonymous credential system that we require shares the core idea of 
Anon-Pass~\cite{AnonPass}.
Anon-Pass builds on the work of \citet{HowToWinTheCloneWars}, but makes some 
changes and, more importantly, implements the scheme and measures performance.
We will proceed with a short note on notation about \ac{ZKPK}, then we will 
proceed with the desired properties for the anonymous credentials.


\subsubsection{Zero-knowledge proofs of knowledge}%
\label{ZKPK}

We will use the notation introduced by \citet{PKnotation}:
\begin{equation}\label{PKexample}
  \PK{\alpha, \beta, \gamma}
  {y = g^\alpha h^\beta \land y' = \hat g^\gamma}
\end{equation}
which means that we prove knowledge of \(\alpha, \beta, \gamma\) ensuring that 
\(y, y'\) are of the form \(y = g^\alpha h^\beta\) and \(y' = \hat g^\gamma\), 
respectively.
Greek letters are known only to the prover and for which the prover wishes to 
prove knowledge, all other letters are known by the verifier.

When a proof of knowledge is turned into a signature using the Fiat-Shamir 
heuristic~\cite{FiatShamirHeuristic}, we will denote it as
\begin{equation*}\label{SPKexample}
  \sigma\gets \SPK{\alpha, \beta, \gamma}
  {y = g^\alpha h^\beta \land y' = \hat g^\gamma}
  {m},
\end{equation*}
which yields a signature \(\sigma\) on \(m\), ensuring that the issuer knew 
\(\alpha, \beta, \gamma\) such that \(y = g^\alpha h^\beta\) and \(y' = 
  \hat{g}^\gamma\).


\subsubsection{Instantiations of the \acs{ZKPK} protocols}

\NewAlgorithm{\PKprove}{PK.\!Prove}
\NewAlgorithm{\PKverify}{PK.\!Verify}

We will rely on the Schnorr identification scheme~\cite{Schnorr}, which in its 
original form can be written as \(\PK{\alpha}{A = g^\alpha}\).
The generalized form would be \(\PK{\alpha_1, \dotsc, \alpha_n}{A = 
    \prod_{i=1}^n g_i^{\alpha_i}}\).
This could equivalently be written as
\begin{equation*}
  \PKprove[\{g_i\}_i, q, A, \{\alpha_i\}_i] \leftrightarrow
  \PKverify[\{g_i\}_i, q, A],
\end{equation*}
where \(\PKprove\) is run by the prover and \(\PKverify\) is run by the 
verifier.
\(\PKverify\) outputs accept (1) or reject (0).
We give an instance of \(\PKprove\) and \(\PKverify\) in \cref{PKalgorithms}.
We also note that
\begin{multline*}
  \PK{\alpha, \beta}{A = g^\alpha \land B = g^\beta} = \\
  \PK{\alpha}{A = g^\alpha} \land \PK{\beta}{B = g^\beta},
\end{multline*}
however, the challenge \(c\) must be the same in both sub-protocols.

\begin{figure*}
  \centering
  \begin{tabular}{lcl}
    \(\PKprove[\{g_i\}_{i=1}^n, q, A, \{\alpha_i\}_{i=1}^n]\):
    &
    & \(\PKverify[\{g_i\}_{i=1}^n, q, A]\):
    \\
    \midrule

    \(\forall i, 1\leq i\leq n\colon \rho_i\rgets \Z_q\)
    &
    &
    \\

    \(R\gets \prod_{i=1}^n g_i^{\rho_i}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    % null
    & \(\ProtoSendLeft{c}\)
    & \(c\rgets \bin^k\)
    \\

    \(1\leq i\leq n\colon s_i\gets \rho_i - c\alpha_i \mod q\)
    & \(\ProtoSendRight{\{s_i\}_{i=1}^n}\)
    &
    \\

    % null
    &
    & \(R \stackrel{?}{=} A^c \prod_{i=1}^n g^{s_i}\)
    \\
    
  \end{tabular}
  \caption{%
    \(\PK{\alpha_1, \dotsc, \alpha_n}{A = \prod_{i=1}^n g_i^{\alpha_i}}\) using 
    the Schnorr identification scheme.
  }%
  \label{PKalgorithms}
\end{figure*}

The Schnorr protocol in itself only provides honest-verifier zero-knowledge.
To achieve malicious-verifier zero-knowledge, we have to choose \(k\) (size of 
the challenge, see \cref{PKalgorithms}) logarithmic in the security parameter 
\(\lambda\) and repeat the protocol sufficiently many times (also logarithmic in 
the security parameter).

\NewAlgorithm{\SPKprove}{SPK.\!Prove}
\NewAlgorithm{\SPKverify}{SPK.\!Verify}

For the non-interactive instance, \(\SPK{\alpha}{A = g^\alpha}{m}\), we use the 
Fiat-Shamir heuristic~\cite{FiatShamirHeuristic} on the above protocol, 
illustrated as \(\SPKprove\) and \(\SPKverify\) in \cref{SPKalgorithms}.

\begin{figure*}
  \begin{minipage}[t]{0.49\linewidth}
    \begin{algorithmic}
      \Function{$\SPKprove$}{$\{g_i\}_i, q, A, \{\alpha_i\}_i, m$}
        \State{\(\forall i, 1\leq i\leq n\colon \rho_i\rgets \Z_q\)}
        \State{\(R\gets \prod_{i=1}^n g_i^{\rho_i}\)}
        \State{$c \gets H(\{g_i\}_i|A|R|m)$}
        \For{$1\leq i\leq n$}
          \State{$s_i \gets \rho_i - c\alpha_i \mod q$}
        \EndFor{}
        \State{\Return{$(\{s_i\}_i, c)$}}
      \EndFunction{}
    \end{algorithmic}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.49\linewidth}
    \begin{algorithmic}
      \Function{$\SPKverify$}{$\{g_i\}_i, q, A, m, \{s_i\}_i, c$}
        \State{$\hat R \gets A^c \prod_{i=1}^n g_i^{s_i}$}
        \If{$c = H(\{g_i\}_i|A|\hat R|m)$}
          \State{\Return{1}}
        \Else{}
          \State{\Return{0}}
        \EndIf{}
      \EndFunction{}
    \end{algorithmic}
  \end{minipage}
  \caption{%
    \(\SPK{\alpha_1, \dotsc, \alpha_n}{A = \prod_{i=1}^n g_i^{\alpha_i}}{m}\) 
    using the Fiat-Shamir heuristic on the Schnorr identification scheme.
  }%
  \label{SPKalgorithms}
\end{figure*}


\subsubsection{Needed properties}

%For an anonymous credential system (\(\ACscheme\)), it is sufficient to have a 
%commitment scheme (\(\ACcommit\)), a signature scheme and (efficient) protocols 
%for
%\begin{enumerate*}
%  \item proving equality of two committed values (\(\ACeq\));
%  \item getting a signature on a committed value (\(\ACreq, \ACissue\)); and
%  \item proving knowledge of a signature on a committed value 
%    (\(\ACprove\))~\cite{CLsignatures}.
%\end{enumerate*}

\NewCryptoScheme{\AC}{AC}

We need an anonymous credential system, \(\AC\), which provides the following 
algorithms and properties.

\NewAlgorithm{\ACcommit}{\AC.\!Commit}
\NewAlgorithm{\ACeq}{\AC.\!ProveEq}
\NewAlgorithm{\ACverifyEq}{\AC.\!VerifyEq}

\(\AC\) must provide a commitment scheme, \(\ACcommit\), and algorithms 
\(\ACeq\leftrightarrow \ACverifyEq\).
% XXX Review requirements of AC.commit
We prefer that the commitment scheme is \emph{perfectly hiding} and 
computationally binding, rather than the other way\footnote{%
  We are more concerned with long-term privacy, thus information-theoretic 
  hiding.
}.
A prover can use \(\ACeq[c, o, c', o', x]\leftrightarrow \ACverifyEq[c, c']\) to 
convince a verifier that \(c = \ACcommit[x, o], c' = \ACcommit[x, o']\), i.e.\ 
both commitments are commitments to the same value \(x\) --- without revealing 
\(x\).

\NewAlgorithm{\ACsign}{\AC.\!Sign}
\NewAlgorithm{\ACgetSig}{\AC.\!GetSig}
\NewAlgorithm{\ACissueSig}{\AC.\!IssueSig}

\NewAlgorithm{\ACproveSig}{\AC.\!ProveSig}
\NewAlgorithm{\ACverifySig}{\AC.\!VerifySig}

\(\AC\) must also provide a signature scheme with protocols to get a signature 
on a commtted value (\(\ACgetSig\leftrightarrow \ACissueSig\)) and to prove 
knowledge of a signature on a committed value (\(\ACproveSig\leftrightarrow 
  \ACverifySig\)).
The prover commits to a value \(x\) with commitment \(c\gets \ACcommit[x, o]\) 
and opening \(o\).
The he uses \(\sigma\gets \ACgetSig[x, c, o, vk]\leftrightarrow \ACissueSig[c, 
  sk]\), where \((vk, sk)\) is the signature--verification keypair, to obtain a 
signature \(\sigma = \ACsign[x][_{sk}]\) on the value \(x\).

At a later point, the prover wants to prove to a verifier that he knows \(x\) 
and a signature \(\sigma\) on \(x\) made by the owner of \(pk\), i.e.\ without 
revealing \(x\) nor \(\sigma\).
The prover and verifier will run the protocol \(\ACproveSig[x, \sigma, 
  pk]\leftrightarrow \ACverifySig[pk]\).

\NewAlgorithm{\ACprf}{\AC.\!PRF}
\NewAlgorithm{\ACprovePRF}{\AC.\!ProvePRF}
\NewAlgorithm{\ACverifyPRF}{\AC.\!VerifyPRF}

Finally we need \iac{PRF}, \(\ACprf\), such that there exists a protocol 
\(\ACprovePRF[k, y, x]\leftrightarrow \ACverifyPRF[y]\) such that the prover can 
convince the verifier that \(y = \ACprf[x][_k]\) without revealing \(k, x\).

% XXX Replace \PRF
\NewFunction{\PRF}{PRF}


\subsubsection{Instantiations of the anonymous credentials} 

The \(\AC\) scheme can be instantiated using the Pedersen 
commitment~\cite{PedersenCommitment} for \(\ACcommit\),
CL-signatures~\cite{CLsignatures} for \(\ACsign, \ACgetSig, \ACissueSig\) and
the \ac{VRF} by \citet{DYVRF} as \(\ACprf\).
These are used together in e.g.\ Anon-Pass~\cite{AnonPass} and by 
\citet{HowToWinTheCloneWars} to form unclonable subscriptions.
