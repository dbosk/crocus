\section{Bit-by-bit distance-bounding Schnorr protocol}%

One protocol exists in the literature that provides \acp{PPK} with most of the desired properties described previously, ProProx~\cite{ProProx}\footnote{Note that~\cite{ProProx} uses the abbreviation PoPoK, we prefer \acs{PPK} for shorter notation.}.
ProProx is secure against a malicious verifier, but it provides \iac{PPK} protocol for quadratic residues (\ie protocols of the form \(\PPK[\alpha][a = 
  \alpha^2]\)), while in our context, we need \iac{PPK} protocol for discrete logarithms (\ie \(\PPK[\alpha][a = g^\alpha]\)) due to our choice of anonymous credentials whose desirable properties we list in \cref{ZK-anon-cred}.%, which in turn is due to their \ac{PRF} for deriving identifiers from a long-term ID with unlinkability to the original ID but with proof of validity of this derivation. 
To realize this, we will now introduce such a protocol to enable us to have \ac{DB} anonymous credentials.

\subsection{Reattempting a distance-bounding Schnorr protocol}%
\label{DBSchnorr-n-bit}

In the original \ac{DB} paper by \citet{DistanceBounding}, one of the distance-bounding protocols is based on the Schnorr identification scheme~\cite{Schnorr}.
However, this \ac{DB} Schnorr protocol was shown to be prone to distance hijacking~\cite{DistanceHijacking, TamarinDB}, in addition to not being secure against terrorist fraud.
We now propose another way to turn the Schnorr protocol into a public-key \ac{DB} protocol that is secure against \ac{DBMF}, \ac{DBDF}, \ac{DBDH} and \ac{DBTF}.
It is important in our setting that the protocol is a public-key protocol, both to reach strong privacy properties and also because this property implies protection against an impersonating verifier.

We present the protocol in \cref{SchnorrFigure}.
The (cyclic) group with generator \(g\) and order \(q\) are system parameters.
The private key \(\alpha\) with public key \(A = g^\alpha\) are generated once by the prover in the setup phase.

\begin{figure*}
  \centering
  \small
  \setlength{\ProtoArrowLength}{0.07\linewidth}
  \begin{tabular}{p{0.40\linewidth}cp{0.40\linewidth}}
    \(\DBSprove[g, q, \alpha, A = g^\alpha]\):
    & &
    \(\DBSverify[g, q, A]\):
    \\
    \midrule

    \multicolumn{3}{c}{\textbf{Setup}} \\

    \(\rho\rgets \ZZ_q, R\gets g^{\rho}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    % null
    & \(\ProtoSendLeft{c_0, c_1}\)
    & \(c_0\rgets \bin^k, c_1\rgets \bin^k\)
    \\

    \(s_0\gets \rho - c_0\alpha \pmod q\)
    &
    & \(b\rgets \bin\)
    \\

    \(s_1\gets \rho - c_1\alpha \pmod q\)
    &
    & Prepare \(B\in \bin^{|q|+l}\), with \(|q|\) bits set to \(b\).
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}: \(\forall i: 0\leq i < |q| + 
        l, j\gets 0\)} \\

%    % null
%    &
%    & Random delay
%    \\

    % null
    & \(\ProtoSendLeft{b_i}\)
    & \(b_i\gets B[i]\)
    \\

    \(r_i\gets s_{b_i}[jb_i + (i-j)(1-b_i)]\)
    & \(\ProtoSendRight{r_i}\)
    & Record \(\Delta t_i\)
    \\

    \(j \gets j + b_i\)
    &
    &
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Construct \(s_b\) as the concatenation of \(r_i\)'s for which \(b_i = 
      b\).
      Accept if \(R = g^{s_b} A^{c_b}\).
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSprove\leftrightarrow \DBSverify\) \ac{DB} Schnorr protocol for \(\PK[\alpha][A = g^\alpha]\).
    The protocol should be repeated in full to achieve the desired knowledge and distance-bounding errors.
  }%
  \label{SchnorrFigure}
\end{figure*}

During one round, the prover commits to a random nonce: more precisely he chooses \(\rho\rgets \ZZ_q\) uniformly at random, computes \(R\gets g^\rho\) and sends \(R\) to the verifier.
The verifier generates two challenges \(c_0\rgets \bin^k, c_1\rgets \bin^k\) and sends them to the prover.
The prover computes \(s_0\gets \rho - c_0\alpha, s_1\gets \rho - c_1\alpha\).
This step is the main difference to the original Schnorr protocol: the verifier selects two challenges and the prover computes two responses --- but still only \emph{one nonce}, \(\rho\).
This is also different from the original Brands-Chaum protocol, in which the 
prover and verifier jointly construct \emph{one} challenge with \emph{one} 
response.

We let \(|q| = \ceil{\log_2 q}\) denote the length of \(q\) in bits.
The verifier will request all \(|q|\) response-bits from one challenge (say 
\(s_b\)) and only \(0 < l\leq |q|\) from the other (\(s_{1-b}\)).
Then the verifier can authenticate the prover by checking if \(R = 
  g^{s_b}A^{c_b}\).

\subsection{Security analysis}

The prover must know the responses for both challenges to successfully pass the \ac{DB} phase.
The reason for the two challenges but only one random nonce is that knowing the responses to both means learning \(\alpha\).
This allows us to prevent \ac{DBTF}.
Bundling the authentication into the distance-bounding phase (difference from Brands-Chaum) prevents \ac{DBDH}, and both adaptations together aim at \ac{DBMF} resistance. %reducing success of MF according to number of repetitions.
The reason we use secret sharing and not \(s_b\) directly, is to bound the \(l\) bits the verifier must learn of \(s_{1-b}\).
Without secret sharing, the verifier learns \(l\) bits of \(s_{1-b}\), but with secret sharing the verifier learns \(l\) bits of \emph{one share}.
Thus, we still have information theoretic security for \(s_{1-b}\) although we reveal the \(l\) bits.

The intuition behind the protocol security is as follows.
To achieve malicious-verifier zero-knowledge, choose \(k\) logarithmic in the security parameter \(\lambda\) and repeat the protocol \(n\) times, such that 
the knowledge error, \(2^{-kn}\), becomes small enough.
Repeating the protocol is also needed to decrease the success probability of some of adversaries presented below.

The \ac{DB} phase protects against distance fraud.
Once the prover has received \(l+1\) challenges set to \(b\), it knows that the remaining challenges must also be \(b\).
\Iac{DBDF} prover must thus wait for the challenge bit \(b_i\) before responding with \(r_i\) for \(l+1\) challenges.
Thus, the probability of successfully guessing the order of the challenge bits is \(2^{-(l+1)}\) per round or, in total, \(2^{-(l+1)n}\).

The \ac{DB} phase also ensures that \iac{DBMF} adversary will fail the \ac{DB} phase for at least one round.
The verifier will send \(|q| + l < 2|q|\) challenges.
By replying, the prover reveals \(|q|+l\) bits distributed over \(s_0, 
  s_1\).
\emph{We assume} that learning \(\ceil{(|q|+l)/2}\) bits of \(s_0\) and 
\(\floor{(|q|+l)/2}\) bits of \(s_1\) yields no advantage for the adversary.
Now, the adversary has two options.
First, the adversary can buffer \(l\) bits of both \(s_0^{(0)}\concat s_0^{(1)}, s_1^{(0)}\concat s_1^{(1)}\) by requesting them from the prover.
However, at this point the adversary must wait for the challenge bit \(b_{l+1}\) from the verifier and then relay that challenge to the prover to receive the correct \(r_i\) --- this relay will be detected.
The alternative is to guess \(b\) and extract \(s_b\) for this challenge from the prover.
Guessing \(b\) yields \(1/2\) probability that the \ac{DBMF} adversary will guess it correctly.
Since we must execute the protocol \(n\) times, the probability to pass all these rounds is reduced to \(2^{-n}\).
If the adversary requests \(s_b\) in full, the adversary can also guess the 
remaining \(|q|-l\) bits of \(s_{1-b}\).
Based on our assumption above, the probability of guessing these bits 
successfully is \(2^{-(|q|-l)}\).
Thus the success probability of the \ac{DBMF} adversary is \emph{at most} 
\(2^{-n}+2^{-(|q|-l)n}\).

The protocol is \ac{DBTF}-resistant. 
Indeed, if the malicious prover gives both responses to the accomplice, the accomplice can compute his secret key.
The probability of success of \ac{DBTF} is thus reduced to guessing \(b\), \ie \(1/2\) per round or, in total, \(2^{-n}\).

The protocol is also secure against distance hijacking due to the fact that the authenticated bitstring is used during the \ac{DB} phase, not the challenge bitstring as it is the case for the original protocol of Brands-Chaum.
Thus the probability of success is equivalent of a collision for the responses 
for the chosen challenge --- in each round.

Finally, it follows from the original Schnorr protocol that this is still \iac{PK} and \ac{ZK}.
\daniel{I should prove this for the composed protocol, I should check the details with Douglas.}

\subsection{The \(l\)-bit problem}

\paragraph*{A special case}

We will start with a special case of the \(l\)-bit problem.
For a session~\(i\), we have two possible responses to the two challenges:
\(s_i = r_i + c\alpha\) and \(s_i' = r_i + c'\alpha\).
Let \(c = 1\) and \(c' = 0\).
We assume that the adversary learns all \(m\) bits of \(s_i\), but only \(l\) 
bits of \(s_i'\).
This special case yields the linear equation system
\begin{align*}
  s_i &= r_i + \alpha
  = s_i'[m-1] 2^{m-1} + \dotsb + s_i'[1] 2^1 + s_i'[0] 2^0 + \alpha \\
  s_i'[j_1] &= b_{j_1} \\
  s_i'[j_2] &= b_{j_2} \\
  \vdots \\
  s_i'[j_l] &= b_{j_l},
\end{align*}
where \(s_i'[j]\) denotes the \(j\)th bit of \(s_i'\), and \(j_1, \dotsc, 
j_l\in \{0, \dotsc, m-1\}\) are indices for the bits chosen by the adversary 
and \(b_{j_1}, \dotsc, b_{j_l}\in \bin\) are the bit values.

\begin{lemma}
  Assume the special case given above.
  If \(l \leq \frac{m+\frac{1}{n}-1}{2}\), then the equation system is 
  underdetermined and we cannot solve for \(\alpha\).
\end{lemma}
\begin{proof}
  The equation system above yields \(l+1\) equations and \(m-l+1\) unknowns.
  If we repeat the protocol \(n\) times, we get \(n\) such sessions.
  This yields an equation system of \(n(l+1)\) equations and \(n(m-1)+1\) 
  unknowns (the unknown \(\alpha\) is not repeated).
  If \(n(l+1) < n(m-l)+1\), this system is underdetermined and cannot be 
  solved.
  After some rewriting we find that
  \begin{align*}
    n(l+1) &< n(m-l)+1 \\
    n(2l+1) &< nm+1 \\
    2l+1 &< m + \frac{1}{n} \\
    2l &< m + \frac{1}{n} -1 \\
    l &< \frac{m + \frac{1}{n} -1}{2}.
  \end{align*}
  Which concludes the proof.
\end{proof}

The number of possible solutions is vital for us, since that is an estimate of 
how difficult it is for the adversary to guess \(\alpha\).

\begin{lemma}\label{l-bit-advantage}
  Assume the special case above.
  There are \(m-l\) free variables, each taking a value from \(\bin\).
  This yields \(2^{m-l}\) possible solutions for each session.
\end{lemma}
\begin{proof}
  The result directly follows from the fact that there are \(m-l\) free 
  variables.
  Each free variable can only take two possible values (0 or 1), consequently 
  there are \(2^{m-l}\) possible combinations.
\end{proof}

\paragraph*{The general \(l\)-bit problem}

For any choice of \(c\) and \(c'\), we have
\begin{align}
  \label{eqn:general-c}
  s_i &= r_i + c\alpha \\
  \label{eqn:general-cprime}
  s_i' &= r_i + c'\alpha.
\end{align}
We can transform this system of equations into our special case above by 
Gaussian elimination: add \cref{eqn:general-c} multiplied by \(\frac{c'}{c}\) 
to \cref{eqn:general-cprime}.
This proves the following lemma.

\begin{lemma}
  Any choice of \(c, c'\) can be turned into our special case of \(c = 1, c' = 
  0\).
\end{lemma}

This means that \cref{l-bit-advantage} is also true for the general case.

\paragraph*{The most general \(l\)-bit problem}

We run the protocol \(n\) times and let the adversary learn \(m+l\) bits of the 
result~\(s_i, s_i'\).
This yields the following equation system:
\begin{align*}
  s_0[0]2^0 + \dotsb + s_0[m-1]2^{m-1} &= r_0 + c\alpha \\
  s_0'[0]2^0 + \dotsb + s_0'[m-1]2^{m-1} &= r_0 + c'\alpha \\
  \vdots \\
  s_{n-1}[0]2^0 + \dotsb + s_{n-1}[m-1]2^{m-1} &= r_{n-1} + c\alpha \\
  s_{n-1}'[0]2^0 + \dotsb + s_{n-1}'[m-1]2^{m-1} &= r_{n-1} + c'\alpha,
\end{align*}
where \(m+l\) of \(s_i[j]\)'s and \(s_i'[j']\)'s for each \(i\) are known by 
the adversary.

\begin{theorem}
  If \[l < m-1+\frac{1}{n}-\frac{f(\lambda)}{n},\] then there are at least 
  \(2^{f(\lambda)}\) possible solutions, for some function~\(f\) of the 
  security parameter~\(\lambda\).
\end{theorem}
\begin{proof}
  Consider one instance of the protocol:
  \begin{align*}
    s_i[0]2^0 + \dotsb + s_i[m-1]2^{m-1} &= r_i + c\alpha \\
    s_i'[0]2^0 + \dotsb + s_i'[m-1]2^{m-1} &= r_i + c'\alpha.
  \end{align*}
  This yields \(2m+2\) variables with two equations, thus \(2m\) free variables.
  Let the adversary learn \(m+l\) of the bits, \ie left-hand side \(s_i[j]\)'s or 
  \(s_i'[j']\)'s.
  This leaves \(2m-(m+l) = m-l\) free variables and \(2^{m-l}\) possible 
  solutions.

  Repeat this \(n\) times.
  This yields \(n(2m+1)+1\) variables and \(2n\) equations, thus \(2nm+n+1-2n = 
  2mn - n +1 = n(2m-1)+1\) free variables.
  Let the adversary learn \(m+l\) bits in each round, thus \(n(m+l)\) in total.
  This yields \(n(2m-1)+1 -n(m+l) = 2nm-n+1-nm-nl = nm-n+1-nl = n(m-1-l)+1\) 
  free variables and \(2^{n(m-1-l)+1}\) possible solutions.
  Consequently, if we want \(f(\lambda)\) possible solutions, we have that
  \begin{equation*}
    nm-n-nl+1 > f(\lambda) \iff m-1+\frac{1}{n}-\frac{f(\lambda)}{n} > l.
  \end{equation*}
  Which concludes the proof.
\end{proof}

\subsection{Formal Verification}

We wanted to formally verify the protocol security properties. To realize this, 
we used the Tamarin prover~\cite{meier2013tamarin}. Tamarin does not include 
originally the possibility to reason on time and space in its model.
However, thanks to a recent work by \textcite{TamarinDB}, all the common 
properties mentioned in the previous subsection can be equivalently 
characterized with a causality-based definition relying only on the order of 
messages.

The whole Tamarin code we wrote is provided in \cref{apdx:tamarin-spec}, with a short discussion of the modeling choices that we have made. 
It contains a specification of the distance-bounding protocol described previously, a definition of the soundness and correctness properties that ensure the protocol actually produces the expected result, and a definition of the security properties we want to ensure.

Tamarin's auto-prover validated the soundness and correctness properties (in negligible computation time) but does not terminate when trying to prove the security properties.
This means that no trace violating the security properties is found, but the prover cannot conclusively validate that the desired properties are true. 
We are currently investigating the Tamarin interactive mode to validate as well the security properties.


