\subsection{\Acl*{DB} protocols}%
\label{distance-bounding}

\Ac{DB} protocols were first suggested by \citet{DistanceBounding} to prevent relay attacks in contactless communications in which the adversary forwards a communication between a prover and a possibly far-away verifier to authenticate. 
These attacks cannot be prevented by cryptographic means as they are independent of the semantics of the messages exchanged.
As a consequence, mechanisms ensuring the physical proximity between a verifier and a prover should be used instead.
\Ac{DB} protocols precisely enable the verifier to estimate an upper bound on his distance to the prover by measuring the time-of-flight of short challenge-response messages (or rounds) exchanged during time-critical phases. 
Time critical phases are complemented by slow phases during which the time is not taking into account. 
At the end of a \Ac{DB} protocol, the verifier should be able to determine if the prover is legitimate \emph{and} in his vicinity.
In this sense, \Ac{DB} protocols combine the classical properties of authentication protocols with the possibility of verifying the physical proximity.

There are four adversaries for \ac{DB} protocols established in the literature, 
each of which tries to commit a type of fraud.
These can be summarized as follows:
\begin{itemize}
  \item \Acf{DBDF}: a legitimate but malicious prover wants to fool the verifier on the distance between them.
  \item \Acf{DBMF}: the adversary illegitimately authenticates using a, 
    possibly honest, prover who is far away from the verifier.
    (Also known as relaying attack or man-in-the-middle attack.)
  \item \Acf{DBTF}: a legitimate, but malicious, prover helps an accomplice, 
    who is close to the verifier, to authenticate.
    \Ac{DBTF} resistance is a very strong property; it implies that if the 
    accomplice succeeds (with non-negligible probability) he will learn the 
    prover's secret key\footnote{%
      This means that even things like functional encryption will not help.
    }.
  \item \Acf{DBDH}: similar to \ac{DBDF}, the malicious prover is far away but 
    uses an unsuspecting honest prover close to the verifier to pass as being 
    close.
    (This is different from \ac{DBMF} in that the honest prover actually tries 
    to authenticate to the verifier, but the malicious prover hijacks the 
    channel at some point(s) during the protocol.)
\end{itemize}

The majority of the existing \ac{DB} protocols are symmetric and thus require an honest verifier.
In this context it does not make sense to protect against the verifier as he 
can easily impersonate the prover as he has a knowledge of his secret key.
There has been less work done in the domain of asymmetric (or public-key) \ac{DB} protocols.
We will work in the latter setting; with a \emph{malicious verifier} who will 
potentially try to \emph{impersonate the prover} after successful verification.

\subsection{\Acl*{DB} security definitions}%
\label{DB-definitions}

There are two lines of attempts at formalizing the above properties: one by 
\citet{DB-BMV} and another by \citet{DB-DFKO}.
We will use the framework of \citeauthor{DB-DFKO} with extensions by 
\textcite{FormalTerroristFraud} and \textcite{TREAD} (definitions in 
\cref{DB-definitions}).

As summarized in by \textcite{TREAD}, there are three types of sessions for an 
adversary:
\begin{description}
  \item[Prover--verifier] The adversary observes an honest execution.
  \item[Prover--adversary] The adversary runs the protocol as a verifier with 
    an honest prover.
  \item[Adversary--verifier] The adversary runs the protocol as a, potentially 
    malicious, prover with an honest verifier.
\end{description}
Each session is associated with a unique identifier \(\sid\).
Each adversary is defined in terms of
computational resources, time~\(t\);
number of prover--verifier sessions observed, \(\qobs\);
number of prover--adversary sessions initiated, \(\qp\), and
number of adversary--verifier sessions initiated, \(\qv\).

The DFKO framework~\cite{DB-DFKO} uses an abstract clock~\(\marker\colon \NN\to 
  \NN\) which is strictly increasing and orders the adversary's actions.
We let
\(\Xscript{\sid}{i, \dotsc, j}\)
denote the sequence of messages
\((m_i, \dotsc, m_j)\)
exchanged during the session \(\sid\).

A session consists of three phases: a setup phase, a time-critical phase and a 
verification phase.
Both setup and verification can be run slowly, but the time-critical phase must 
be run as fast as possible.

\paragraph*{\Acl*{DBMF}}

We will now define the conditions for \ac{DBMF} and \ac{DBMF} resistance.
A tainted session is a session in which the adversary lost because the verifier 
detected the attempt at cheating, \eg the timing is too long because the 
adversary is out of range.
The following definition captures a pure relay and a verifier is assumed to 
detect such a relay.

\begin{definition}[Tainted session, \acs*{DBMF}~\cite{DB-DFKO}]%
  \label{TaintedMF}
  A time-critical round
  \(\Xscript{\sid}{k, k+1} = (m_k, \dotsc, m_{k+1})\)
  of an adversary--verifier session~\(\sid\), where \(m_k\) is sent by the 
  verifier, is \emph{tainted} by the round
  \(\Xscript{\sid'}{k', k'+1} = (m_{k'}, m_{k'+1})\)
  of a prover--adversary session~\(\sid'\) if
  \begin{align*}
    (m_k, m_{k+1}) &= (m_{k'}, m_{k'+1}) \\
    \marker[\sid, k] &< \marker[\sid', k'] \\
    \marker[\sid, k+1] &> \marker[\sid', k'+1].
  \end{align*}
\end{definition}

We will now define what is means for a protocol to be \ac{DBMF} resistant.

\begin{definition}[\acs*{DBMF} resistance~\cite{TREAD}]%
  \label{MFresistance}
  For \iac{DB} authentication scheme \(\DB\), a \((t, \qobs, \qp, \qv)\)-MF 
  adversary \(\adv\) \emph{wins} against \(\DB\) if the verifier accepts 
  \(\adv\) in in one of the \(\qv\) adversary--verifier sessions \(\sid\), 
  which does not have any critical phase tainted by a prover--adversary session 
  \(\sid'\).
  The protocol \(\DB\) is \Ac{DBMF} resistant if the probability 
  \(\Adv_{\DB}^{\text{MF}}(\adv)\) that \(\adv\) wins the game is negligible in 
  the security parameter.
\end{definition}

\paragraph*{\Acl*{DBTF}}

\Acl{DBTF} is similar to \ac{DBMF}, the difference is that during \ac{DBTF} the 
prover cooperates with the adversary to make the verifier accept.

\daniel{The following definition differs slightly from that of 
  \textcite{FormalTerroristFraud}: we use \(m_{k'}\) instead of \(m_k'\).
  \Ie that the number of messages in \(\sid\) is not required to be the same 
  and in the same order as in \(\sid'\).}

\begin{definition}[Tainted session, \acs*{DBTF}]\label{TaintedTF}
  A time-critical round
  \(\Xscript{\sid}{k, k+1} = (m_k, m_{k+1})\)
  of an adversary--verifier session~\(\sid\), where \(m_k\) is sent by the 
  verifier, is \emph{tainted} by the round
  \(\Xscript{\sid'}{k', k'+1} = (m_{k'}, m_{k'+1})\)
  of a prover--adversary session~\(\sid'\) if
  \begin{align*}
    \marker[\sid, k] &< \marker[\sid', k'] \\
    \marker[\sid, k'+1] &> \marker[\sid', k'+1].
  \end{align*}
\end{definition}

\begin{definition}[strSimTF resistance~\cite{FormalTerroristFraud}]%
  \label{TFresistance}
  \dots
\end{definition}

\paragraph*{\Acl*{DBDH} and \acl*{DBDF}}

\begin{definition}[Tainted session, \acs*{DBDH}~\cite{TREAD}]%
  \label{TaintedDH}
  \dots
\end{definition}

\begin{definition}[\acs*{DBDH} resistance~\cite{TREAD}]%
  \label{DHresistance}
  \dots
\end{definition}

These definitions for \ac{DBDH} also captures \ac{DBDF} attacks~\cite{TREAD}.
