\section{Security and privacy analysis}%
\label{SecurityAnalysis}

\subsection{Individual and universal verifiability}%
\label{analysis-individual}%
\label{analysis-universal}

\Cref{IndividualVerif} requires that Alice and Bob, as participants, can verify 
that their participation proofs (proof shares) are indeed included.
As all proof shares (\ie \(\cid, \pid, \wid, t_s, t_s', t_e, t_e', l, \wsig, 
  \pi_\pid, \pi_{\wid, \wsig}\)) are committed to the blockchain and available 
from public storage (see \cref{fig:ProtocolOverview}).
Alice and Bob can simply check that all of their proof shares are indeed there 
and thus the security of individual verifiability depends on the properties of 
the blockchain and storage.

\Cref{UniversalVerif} requires that also anyone can verify the result and that 
all participation proofs counted indeed are eligible.
As the proof shares are committed and stored publicly, anyone can download them, 
verify eligibility (\ie verify \(\pi_\pid, \pi_{\wid, \wsig}\)) the proofs and 
count them.
As for individual verifiability, the security of universal verifiability is 
reduced to the properties of the blockchain and storage but also the eligibility 
verification, which we will discuss next.

\subsection{Eligibility verifiability}%
\label{analysis-eligibility}

\Cref{EligibilityVerif} states that anyone must be able to determine the 
authenticity of the relevant attributes of the data.
We have several attributes that must be verifiable:
time of creation (temporal eligibility),
physical location of \(\sk_P\) at creation (spatial eligibility),
recognize two proofs from the same person (one-proof-per-person eligibility) and 
that the proof is indeed designated for the event (designated-event 
eligibility).
We will now analyse these.

\paragraph{Temporal eligibility}%
\label{analysis-temporal}

\Cref{TemporallyRelated} ensures freshness, \ie that we cannot simply resubmit 
an old proof as a new one.
In general, freshness requires the prover to respond to an unpredictable 
challenge.
The challenge here is to include the hash value at the head of the blockchain at 
the time of the proof's creation (included as \(t_s\) and \(t_s'\) in the proof 
share).
As per construction of blockchains, the hash value at the head depends on the 
previous blocks in the chain.
Thus the predictability of \(t_s\) depends on the predictability of the blocks, 
which depends on the predictability of the transactions and the nonce needed by 
the miner.
The transactions in turn depend on the signatures made by the signing keys 
corresponding to the used transactions.
If these were predictable, our adversary could spend arbitrary transactions in 
the blockchain --- which is designed to be hard.
Thus Alice can predict \(t_s\) with negligible probability, \ie \(t_s\) must 
have been published on the blockchain before being included in her proof share.

According to \cref{TemporallyRelated}, we must also prove that a proof share has 
not been created after a certain time.
The hash values of the proof shares are committed to the blockchain, thus there 
is a negligible probability that they were created after that.
Alice would have to choose a value \(y\) in the domain of the hash function 
\(\Hash\) and then find a preimage \(x\) such that \(y = \Hash[x]\) and \(x\) is 
a valid proof.
If \(\Hash\) is collision resistant, then finding \emph{any} preimage is hard.

\paragraph{Spatial eligibility}%
\label{analysis-spatial}

\daniel{Discuss the two alternative approaches: trusted Jane and collusion 
  threshold.
  Do actual security analysis.}
According to \cref{SpatiallyRelated} Alice and Bob must bind their proofs 
(shares) spatially to the location, which would allow us to verify that they 
were actually in that location.
The role of the witnesses is to provide this property.

\paragraph{Linkability}%
\label{analysis-linkability}

\Cref{CountOnce} is required to prevent Sybil attacks, \ie that one individual 
can provide two participation proofs and thus be counted twice.
This is prevented by the use of \(\pid\).
To be counted twice, Alice must produce a \(\pid'\neq \pid\).
Due to the deterministic property of \(\ACprf\), Alice must produce a new key 
\(\sk_P'\) and make the witness accept in the protocol
\begin{multline*}
\PK\mleft\{ (\sk_P') : \pid' = \ACprf[_{\sk_P'}][\cid], \mright. \\
    \sigma_P'' = \mleft. \ACblind[\ACsign[_{\ssk}][\sk_P']] \mright\}
\end{multline*}
while she does not know a valid signature on \(\sk_P'\).
This is thus reduced to the security of the \(\AC\) scheme and how often Alice 
can get a valid signature on a secret key from the \ac{CA}.

\paragraph{Designated protest}%
\label{analysis-designated}

\Cref{DesignatedEvent} is to prevent Alice from reusing the same proof (or proof 
share) for another event --- or someone else using her proof-share for another 
event.
This is prevented with the use of \(\cid\) in the proof shares.
Thus to reuse the proof share for another protest, with a different manifesto, 
one must find a second preimage \(\mfst'\) such that \(\cid = \Hash[\mfst] = 
  \Hash[\mfst']\).

\paragraph{Forging proof shares}

\daniel{This is work-in-progress.}
Alice can attempt to forge the full proof directly, \ie
\begin{multline*}
\pi_{\pid'} = \SPK\mleft\{ (\sk_P') : \mright. \\
  \begin{aligned}
    \pid' &= \ACprf[_{\sk_P'}][\cid], \\
    \sigma_P'' &= \mleft. \ACblind[\ACsign[_{\ssk}][\sk_P']] \mright\}
  \end{aligned} \\
    (\cid, \pid', \wid', t_s, t_s', l, \wsig')
\end{multline*}
and consequently
\begin{multline*}
  \pi_{\wid', \wsig'}\gets \SPK\left\{ (\sk_W') : \right. \\
    \begin{aligned}
      \wid' &= \ACprf[_{\sk_W'}][\pid'] \quad \land \\
      \wsig' &= \ACprf[_{\sk_W'}][\wid', t_s, t_s', l] \quad \land \\
      \sigma_W'' &= \left. \ACblind[\ACsign[_{\ssk}][\sk_W']] \right\}
    \end{aligned} \\
      (\pid', \wid', t_s, t_s', l, \wsig'),
\end{multline*}
and thus solve same problem twice (once for \(pid'\) and once for \(\wid'\)).

