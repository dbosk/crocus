\section{Distance-bounding \aclp*{ZKPK} for discrete logarithms}%
\label{DB-Schnorr}

We will now introduce \iac{DB} protocol which is a \ac{ZKPK} for discrete 
logarithms.
Our protocol is an adaptation of the Schnorr identification 
scheme~\cite{Schnorr}, albeit different from that of 
\textcite{DistanceBounding} in the original \ac{DB} paper\footnote{%
  The \citeauthor{DistanceBounding} protocol was shown to be prone to distance 
  hijacking~\cite{DistanceHijacking,TamarinDB} and was not secure against 
  terrorist fraud.
} and that of \textcite{Bussard-Bagga}\footnote{%
  The \citeauthor{Bussard-Bagga} protocol was also shown to be 
  vulnerable~\cite{Bussard-Bagga-attack}.
  Although this time, the protocol could not protect against \ac{DBTF} and 
  \ac{DBDF} as it claimed.
}.
We propose another way to turn the Schnorr protocol into a public-key \ac{DB} 
protocol which is \iac{ZKPK} that is secure against \ac{DBMF}, \ac{DBDF}, 
\ac{DBDH} and \ac{DBTF}.
This yields strong privacy properties and protection against a malicious, 
impersonating verifier.

We will provide two versions of the protocol.
In the first (\cref{DB-Schnorr-UWB}), we will assume that we can send as many 
bits in parallel as we like.
This is a reasonable assumption thanks to the results of \textcite{UWBPR}.

Next (\cref{DB-Schnorr-PKI}), we will provide \iac{PKI} construction to make 
the shared-key requirement of \textcite{UWBPR} more practical.
This would allow any two devices to run our protocol as long as they are both 
part of the \ac{PKI}.
We use the first version of our protocol to ensure correctness of the \ac{PKI}.

Finally (\cref{DB-Schnorr-nbit}), we provide a classical bit-by-bit version of 
our protocol.


\subsection{Reattempting a distance-bounding Schnorr protocol}%
\label{DB-Schnorr-UWB}

In this version, we assume that we can simply send as many bits in parallel as 
we like.
This allows us to keep the Schnorr protocol almost as is.

We present the protocol in \cref{DB-Schnorr-UWB-figure}.
The (cyclic) group with generator \(g\) and order \(q\) are system parameters.
The private key \(\alpha\) with public key \(A = g^\alpha\) are generated once by the prover in the setup phase.
%Let \(\UWBPR\) be the protocol of \textcite{UWBPR}.
%Further, let
%\(\UWBPRsend[_k][m]\) denote sending a message~\(m\) with the shared key~\(k\),
%\(m'\gets \UWBPRrecv_k\) denote receiving a message~\(m'\) with shared 
%key~\(k\) and finally
%\(\Delta t\gets \UWBPRtime\) denote the time between the last \(\UWBPRsend\) 
%and \(\UWBPRrecv\) operations.

\begin{figure*}
  \centering
  \small
  \setlength{\ProtoArrowLength}{0.07\linewidth}
  \begin{tabular}{p{0.40\linewidth}cp{0.40\linewidth}}
    \(\DBSprove[g, q, \alpha, A = g^\alpha]\):
    & &
    \(\DBSverify[g, q, A]\):
    \\
    \midrule

    \multicolumn{3}{c}{\textbf{Setup}} \\

    \(\rho\rgets \ZZ_q, R\gets g^{\rho}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    \(s_1\gets \rho - c_1\alpha \pmod q\)
    & \(\ProtoSendLeft{c_1, \dotsc, c_m}\)
    & \(c_1\rgets \bin^l, \dotsc, c_m\rgets \bin^l\)
    \\

    \vdots
    &
    &
    \\[-1em]

    \(s_m\gets \rho - c_m\alpha \pmod q\)
    &
    &
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}} \\

    \text{Ready}
    & \ProtoSendRight{\text{Ready}}
    & \\

%    % null
%    &
%    & Random delay
%    \\

    % null
    & \(\ProtoSendLeft{i}\)
    & \(i\rgets \{1, \dotsc, m\}\), start clock
    \\

    Fetch \(s_i\)
    & \(\ProtoSendRight{s_i}\)
    & Stop clock, record \(\Delta t\)
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Accept if \(R = g^{s_i} A^{c_i}\) and \(\Delta t < t_{\max}\).
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSprove\leftrightarrow \DBSverify\) 
    protocol instantiating \(\PK[\alpha][A = g^\alpha]\).
    The protocol should be repeated \(n\) times to achieve the desired 
    soundness and distance-bounding errors.
  }%
  \label{DB-Schnorr-UWB-figure}
\end{figure*}

During one round, in the setup phase, the prover commits to a random nonce: 
more precisely he chooses \(\rho\rgets \ZZ_q\) uniformly at random, computes 
\(R\gets g^\rho\) and sends \(R\) to the verifier.
The verifier generates \(m\) challenges \(c_1\rgets \bin^l, \dotsc, c_m\rgets 
  \bin^l\) (bit strings of length \(l\)) and sends them to the prover.
The prover computes one response per challenge, \(s_1\gets \rho - c_1\alpha, 
  \dotsc, s_m\gets \rho - c_m\alpha\).
This step is the main difference to the original Schnorr protocol: the verifier 
selects several challenges and the prover computes several responses --- but 
still only use \emph{one nonce}, \(\rho\).
This is needed for \ac{DBTF} resistance.
This is also different from the original Brands-Chaum protocol, in which the 
prover and verifier jointly construct \emph{one} challenge with \emph{one} 
response.

In the \ac{DB} phase, the prover notifies the verifier that he has computed 
\(s_1, \dotsc, s_m\).
The verifier chooses one of the challenges, \(i\), uniformly randomly and sends 
it as a challenge to the prover and starts measuring the time of flight.
The prover replies with \(s_i\).
The verifier stops the measurement and verifies that \(R = g^{s_i}A^{c_i}\) and 
that the time of flight was within \(t_{\max}\) (determined from the allowed 
  distance).

This protocol must be repeated \(n\) times.


\subsection{\Acl*{ZK} and \acl*{PK}}\label{UWB-ZKPK}

The main difference between this protocol and the Schnorr protocol is that we 
have the prover compute responses for \(m\) different challenges, \(c_1, 
  \dotsc, c_m\).
However, in the authentication step, the verifier chooses only one of those 
challenges.
From the simulator's (and extractor's) perspective, there is no difference 
whether the verifier first chooses \(m\) and then chooses one of those \(m\) 
challenges, or if the verifier chooses the one challenge directly;
the distribution is the same, \(\frac{m}{n}\times \frac{1}{m} = \frac{1}{n}\).
Therefore the standard proof for Schnorr as a malicious-verifier \ac{ZKPK} 
protocol with soundness error \(2^{-l n}\) still 
holds~\cite[\eg][]{OnSigmaProtocols}.
(We note that \(l\), which is also the length of the challenge bit string, must 
be logarithmic in the security parameter, \(\lambda\), for a malicious 
verifier.)

\subsection{\acs*{DBMF}, \acs*{DBTF} and \acs*{DBDH} resistance}

The intuition behind the protocol security is as follows.
The prover must know the responses for all challenges to successfully pass the 
\ac{DB} phase.
The reason for having several challenges but only one random nonce is that 
knowing at least two responses means learning the secret~\(\alpha\).
This gives us the incentives that prevent \ac{DBTF}.
(We also need it for \ac{DBMF} and \ac{DBDF}.)
Bundling the authentication into the distance-bounding phase (difference from 
Brands-Chaum) prevents \ac{DBDH}.

\paragraph{\Acl{DBMF}}

By \cref{TaintedMF}, any relaying will be detected by the verifier.
This means that the adversary must use a different strategy.

\begin{theorem}[\acs*{DBMF} resistance]
  Let \(\adv\) be a \((t, \qobs, \qp, \qv)\)-MF adversary, then 
  \(\Adv_{\DBS}^{\text{MF}}(\adv) = \frac{1}{m^n}\), where \(m\) is as in 
  \cref{DB-Schnorr-UWB}.
\end{theorem}

\begin{proof}
  It follows from the \ac{ZK} property (\cref{UWB-ZKPK}) that the adversary 
  cannot learn anything by observation.
  This leaves the adversary with two options:
  \begin{enumerate*}
  \item guess which challenge the verifier will use and request the correct 
    response from the prover, receiving the challenge first would taint the 
    session (\cref{TaintedMF});
  \item guess the response.
  \end{enumerate*}
  The first option yields success with probability \(\frac{1}{m}\), since the 
  choice is uniformly distributed.
  The second option yields success with probability \(\frac{1}{q}\): since the 
  response~\(s_i\) depends on \(\rho\), which is uniformly distributed in 
  \(\ZZ_q\), it follows that \(s_i\) is also uniformly distributed in 
  \(\ZZ_q\).

  Since \(m \leq q\), the best strategy is to guess which challenge the 
  verifier will use.
  Thus, the total success probability is \(\frac{1}{m^n}\).
\end{proof}

\paragraph{\Acl{DBTF}}

The protocol is \ac{DBTF} resistant.
Indeed, if the malicious prover gives more than one response to the accomplice, 
the accomplice can compute the secret key and, thus, impersonate forever.
And we show that any useful help will ensure this.

\begin{theorem}[\acs*{DBTF} resistance]
  Let \(\adv\) be a \((t, \qv)\)-strSimTF adversary (aided by the prover), 
  \(\S\) an algorithm with runtime \(t_{\S}\).
  If the verifier's challenges are uniformly drawn, then 
  \(\Adv_{\DB}^{\text{TF}} = p_{\adv} - p_{\S} < \left(\frac{2}{m}\right)^n\).
\end{theorem}

\begin{proof}
  Assume that the adversary~\(\adv\) can authenticate with the prover's help 
  with probability~\(p_{\adv}\) non-negligibly better than guessing (\(p_{\adv} 
  = \frac{1}{m}+\epsilon, \epsilon\) non-negligible), without tainting the 
  session (\cref{TaintedTF}) and leaking the secret~\(\alpha\).
  Say that \(\adv\) has successfully authenticated with the prover's help and 
  \(\S\) is given \(\adv\)'s state.

  Now \(\S\) will use \(\adv\) in a simulation.
  \(\S\) will rewind \(\adv\) to just before \(\adv\) received the challenge.
  Since the challenge is chosen uniformly randomly by the verifier, \(\S\) will 
  choose another challenge different from before.
  Since \(\adv\) cannot perform a relay to the prover without tainting the 
  session (\cref{TaintedTF}) and each challenge is uniformly random, the help 
  provided by the prover must be independent from the chosen challenge.
  Now \(\adv\) will again provide a correct response with 
  probability~\(p_{\adv}\).

  However, since there are \(m\) challenges, \(\S\) can probabilistically extract 
  \(m p_{\adv}\) responses.
  Once \(m p_{\adv} \geq 2\), \(\S\) can compute the secret~\(\alpha\) from two 
  correct responses and, thus, \(p_{\S} = 1\) for any successive 
  authentication.
  This would also make \(p_{\adv} = 1\).
  This contradicts that the secret is not leaked.
  Hence, \(\epsilon < \frac{1}{m}\) or the adversary taints the session or the 
  secret leaks.
\end{proof}

\paragraph{\Acl{DBDH}}

The protocol is also secure against distance hijacking due to the fact that the 
authenticating bit string is used during the \ac{DB} phase.
(Brands-Chaum used the challenge bit string, something that made their protocol 
vulnerable.)
\Ac{DBDH} requires that the adversary finds a collision between his response 
and that of the honest prover.
Thus the probability of success is equivalent to a collision for the responses 
for the chosen challenge --- in each round.

\begin{theorem}[\acs*{DBDH}/\acs*{DBDF} resistance]
  Let \(\adv\) be a \((t, \qobs, \qp, \qv)\)-DH adversary, then 
  \(\Adv_{DBS}^{\text{DH}}(\adv) = \frac{1}{m^n}\).
\end{theorem}

\begin{proof}
  The honest prover will choose \(\rho\) such that \(R = g^\rho\).
  The adversary can send his own \(R' = g^{\rho'}\) to the verifier, or let 
  \(R' = R\) to not interfere.

  The verifier will choose \(c_1, \dotsc, c_k\).
  The honest prover will compute \(s_i = \rho - c_i \alpha\), where \(\alpha\) 
  is his \enquote{private key}\footnote{%
    In Schnorr's original protocol this was called the private key.
    But in our general use, it's the discrete logarithm for which the prover 
    wants to prove knowledge.
  }.
  If the adversary chose \(R' = g^{\rho'}\), he can compute \(s_i' = \rho' - 
  c_i \alpha'\), where \(\alpha'\) is the adversary's \enquote{private key}.
  If the adversary didn't choose \(R'\), he can only guess the values for 
  \(s_i'\).

  Now the adversary has two options:
  to \(\Commit\) to a response or to \(\Prompt\) the honest prover to respond.

  If the adversary \(\Commit\)s:
  If the adversary chose \(R'\), then he knows \(\rho'\) and can compute \(s_i 
  = \rho' - c_i \alpha'\) for all \(i\).
  Now, the adversary must commit to one \(s_i\) before seeing the verifier's 
  choice \(j\).
  The probability of committing to the right one is \(\frac{1}{m}\).
  If the adversary didn't choose \(R'\) and consequently doesn't know \(\rho\), 
  the probability of success is \(\frac{1}{q}\) --- since he must guess 
  \(\rho\) (\(\frac{1}{q}\)) and then guess the challenge (\(\frac{1}{m}\)) he 
  might just as well guess the final outcome (\(\frac{1}{q}\)).
  By design, \(m \leq q\), so \(\frac{1}{m} \geq \frac{1}{q}\).
  The success of committing is \(\frac{1}{m}\).

  If the adversary \(\Prompt\)s:
  The verifier will check that \(R' = g^{s_i} A'^{c_i}\), where \(A'\) is the 
  \enquote{public key}\footnote{%
    In Schnorr's original protocol this was a public key.
    In our more general use, it is the value for which the adversary wants to 
    prove knowledge of a discrete logarithm.
  } of the adversary.
  Now, \(g^{s_i} A'^{c_i} = g^{\rho - c_i \alpha} (g^{\alpha'})^{c_i} = g^{\rho 
  - c_i \alpha + c_i \alpha'}\).
  If \(R' = R = g^\rho\), chosen by the prover, then the verifier will only 
  accept if \(\alpha = \alpha'\), the probability for which is 
  \(\frac{1}{q^2}\).
  If \(R' = g^{\rho'}\), chosen by the adversary, then the verifier accepts 
  with probability \(\Pr[\rho' - c_i \alpha' = \rho - c_i' \alpha] = 
  \frac{1}{q}\).

  Obviously, the better strategy for the adversary is to choose \(R' = 
  g^{\rho'}\).
  It's also a better strategy to \(\Commit\) (\ac{DBDF}) rather than 
  \(\Prompt\) (\ac{DBDH}).
  We thus have that
  \(\Adv_{\DBS}^{\text{DH}}(\adv) = \frac{1}{m^n}\),
  which concludes the proof.
\end{proof}

