\section{Distance-bounding \aclp*{ZKPK} for discrete logarithms}%
\label{DB-Schnorr}

We will now introduce \iac{DB} protocol which is a \ac{ZKPK} for discrete 
logarithms.
Our protocol is an adaptation of the Schnorr identification 
scheme~\cite{Schnorr}, albeit different from that of 
\textcite{DistanceBounding} in the original \ac{DB} paper\footnote{%
  The \citeauthor{DistanceBounding} protocol was shown to be prone to distance 
  hijacking~\cite{DistanceHijacking,TamarinDB} and was not secure against 
  terrorist fraud.
} and that of \textcite{Bussard-Bagga}\footnote{%
  The \citeauthor{Bussard-Bagga} protocol was also shown to be 
  vulnerable~\cite{Bussard-Bagga-attack}.
  Although this time, the protocol could not protect against \ac{DBTF} and 
  \ac{DBDF} as it claimed.
}.
We propose another way to turn the Schnorr protocol into a public-key \ac{DB} 
protocol which is \iac{ZKPK} that is secure against \ac{DBMF}, \ac{DBDF}, 
\ac{DBDH} and \ac{DBTF}.
This yields strong privacy properties and protection against a malicious, 
impersonating verifier.

We will provide two versions of the protocol.
In the first (\cref{DB-Schnorr-UWB}), we will assume that we can send as many 
bits in parallel as we like.
This is a reasonable assumption thanks to the results of \textcite{UWBPR}, we 
briefly explain why.
\Iac{DBMF} adversary can listen in on the communications.
Each symbol of the communication is encoded using signal pulses.
However, such an encoded symbol can usually be inferred \emph{before} all 
pulses are received.
Before the contribution of \citeauthor{UWBPR}, the only countermeasure to this 
attack was to make the symbols short, \ie to send one bit at a time.
\Textcite{UWBPR} use a symmetric key, shared between prover and verifier, to 
scramble the pulses and hence the symbols.
This way, the \ac{DBMF} adversary cannot infer an incoming symbol in advance, 
and thus cannot start relaying the symbol in advance either.
The prover and verifier, on the other hand, can do this since they have the 
symmetric key.
Consequently they must have mutual trust, so \ac{DBDF} cannot happen by 
assumption.

Next (\cref{DB-Schnorr-PKI}), we will provide \iac{PKI} construction to make 
the shared-key requirement of \textcite{UWBPR} more practical.
This would allow any two devices to run our protocol as long as they are both 
part of the \ac{PKI}.
We use the first version of our protocol to ensure correctness of the \ac{PKI}.

Finally (\cref{DB-Schnorr-nbit}), we provide a classical bit-by-bit version of 
our protocol.


\subsection{Reattempting a distance-bounding Schnorr protocol}%
\label{DB-Schnorr-UWB}

In this version, we assume that we can simply send as many bits in parallel as 
we like.
This allows us to keep the Schnorr protocol almost as is.

We present the protocol in \cref{DB-Schnorr-UWB-figure}.
The (cyclic) group with generator \(g\) and order \(q\) are system parameters.
The private key \(\alpha\) with public key \(A = g^\alpha\) are generated once by the prover in the setup phase.
%Let \(\UWBPR\) be the protocol of \textcite{UWBPR}.
%Further, let
%\(\UWBPRsend[_k][m]\) denote sending a message~\(m\) with the shared key~\(k\),
%\(m'\gets \UWBPRrecv_k\) denote receiving a message~\(m'\) with shared 
%key~\(k\) and finally
%\(\Delta t\gets \UWBPRtime\) denote the time between the last \(\UWBPRsend\) 
%and \(\UWBPRrecv\) operations.

\begin{figure*}
  \centering
  \small
  \setlength{\ProtoArrowLength}{0.07\linewidth}
  \begin{tabular}{p{0.40\linewidth}cp{0.40\linewidth}}
    \(\DBSprove[g, q, \alpha, A = g^\alpha]\):
    & &
    \(\DBSverify[g, q, A]\):
    \\
    \midrule

    \multicolumn{3}{c}{\textbf{Setup}} \\

    \(\rho\rgets \ZZ_q, R\gets g^{\rho}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    \(s_1\gets \rho - c_1\alpha \pmod q\)
    & \(\ProtoSendLeft{c_1, \dotsc, c_m}\)
    & \(c_1\rgets \bin^l, \dotsc, c_m\rgets \bin^l\)
    \\

    \(\vdots\)
    &
    &
    \\[-1em]

    \(s_m\gets \rho - c_m\alpha \pmod q\)
    &
    &
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}} \\

    \text{Ready}
    & \ProtoSendRight{\text{Ready}}
    & \\

%    % null
%    &
%    & Random delay
%    \\

    % null
    & \(\ProtoSendLeft{i}\)
    & \(i\rgets \{1, \dotsc, m\}\), start clock
    \\

    Fetch \(s_i\)
    & \(\ProtoSendRight{s_i}\)
    & Stop clock, record \(\Delta t\)
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Accept if \(R = g^{s_i} A^{c_i}\) and \(\Delta t < t_{\max}\).
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSprove\leftrightarrow \DBSverify\) 
    protocol instantiating \(\PK[\alpha][A = g^\alpha]\).
    The protocol should be repeated \(n\) times to achieve the desired 
    soundness and distance-bounding errors.
  }%
  \label{DB-Schnorr-UWB-figure}
\end{figure*}

During one round, in the setup phase, the prover commits to a random nonce: 
more precisely he chooses \(\rho\rgets \ZZ_q\) uniformly at random, computes 
\(R\gets g^\rho\) and sends \(R\) to the verifier.
The verifier generates \(m\) challenges \(c_1\rgets \bin^l, \dotsc, c_m\rgets 
  \bin^l\) (bit strings of length \(l\)) and sends them to the prover.
The prover computes one response per challenge, \(s_1\gets \rho - c_1\alpha, 
  \dotsc, s_m\gets \rho - c_m\alpha\).
This step is the main difference to the original Schnorr protocol: the verifier 
selects several challenges and the prover computes several responses --- but 
still only use \emph{one nonce}, \(\rho\).
This is needed for \ac{DBTF} resistance.
This is also different from the original Brands-Chaum protocol, in which the 
prover and verifier jointly construct \emph{one} challenge with \emph{one} 
response.

In the \ac{DB} phase, the prover notifies the verifier that he has computed 
\(s_1, \dotsc, s_m\).
The verifier chooses one of the challenges, \(i\), uniformly randomly and sends 
it as a challenge to the prover and starts measuring the time of flight.
The prover replies with \(s_i\).
The verifier stops the measurement and verifies that \(R = g^{s_i}A^{c_i}\) and 
that the time of flight was within \(t_{\max}\) (determined from the allowed 
  distance).

This protocol must be repeated \(n\) times.


\subsection{\Acl*{ZK} and \acl*{PK}}\label{UWB-ZKPK}

The main difference between this protocol and the Schnorr protocol is that we 
have the prover compute responses for \(m\) different challenges, \(c_1, 
  \dotsc, c_m\).
However, in the authentication step, the verifier chooses only one of those 
challenges.
From the simulator's (and extractor's) perspective, there is no difference 
whether the verifier first chooses \(m\) and then chooses one of those \(m\) 
challenges, or if the verifier chooses the one challenge directly;
the distribution is the same, \(\frac{m}{n}\times \frac{1}{m} = \frac{1}{n}\).
Therefore the standard proof for Schnorr as a malicious-verifier \ac{ZKPK} 
protocol with soundness error \(2^{-l n}\) still 
holds~\cite[\eg][]{OnSigmaProtocols}.
(We note that \(l\), which is also the length of the challenge bit string, must 
be logarithmic in the security parameter, \(\lambda\), for a malicious 
verifier.)

\subsection{\acs*{DBMF}, \acs*{DBTF} and \acs*{DBDH} resistance}

The intuition behind the protocol security is as follows.
The prover must know the responses for all challenges to successfully pass the 
\ac{DB} phase.
The reason for having several challenges but only one random nonce is that 
knowing at least two responses means learning the secret~\(\alpha\).
This gives us the incentives that prevent \ac{DBTF}.
(We also need it for \ac{DBMF} and \ac{DBDF}.)
Bundling the authentication into the distance-bounding phase (difference from 
Brands-Chaum) prevents \ac{DBDH}.

\paragraph{\Acl{DBMF}}

By \cref{TaintedMF}, any relaying will be detected by the verifier.
This means that the adversary must use a different strategy.

\begin{restatable}[\acs*{DBMF} resistance]{theorem}{UWBMFresistance}
  Let \(\adv\) be a \((t, \qobs, \qp, \qv)\)-MF adversary, then 
  \(\Adv_{\DBS}^{\text{MF}}(\adv) = \frac{1}{m^n}\), where \(m\) is as in 
  \cref{DB-Schnorr-UWB}.
\end{restatable}

The proof is found in \cref{ProofUWBMFresistance}.

\paragraph{\Acl{DBTF}}

The protocol is \ac{DBTF} resistant.
Indeed, if the malicious prover gives more than one response to the accomplice, 
the accomplice can compute the secret key and, thus, impersonate forever.
And we show that any useful help will ensure this.

\begin{restatable}[\acs*{DBTF} resistance]{theorem}{UWBTFresistance}
  Let \(\adv\) be a \((t, \qv)\)-strSimTF adversary (aided by the prover), 
  \(\S\) an algorithm with runtime \(t_{\S}\).
  If the verifier's challenges are uniformly drawn, then 
  \(\Adv_{\DB}^{\text{TF}} = p_{\adv} - p_{\S} < \left(\frac{2}{m}\right)^n\).
\end{restatable}

The proof is found in \cref{ProofUWBTFresistance}.

\paragraph{\Acl{DBDH}}

The protocol is also secure against distance hijacking due to the fact that the 
authenticating bit string is used during the \ac{DB} phase.
(Brands-Chaum used the challenge bit string, something that made their protocol 
vulnerable.)
\Ac{DBDH} requires that the adversary finds a collision between his response 
and that of the honest prover.
Thus the probability of success is equivalent to a collision for the responses 
for the chosen challenge --- in each round.

\begin{restatable}[\acs*{DBDH}/\acs*{DBDF} 
  resistance]{theorem}{UWBDFresistance}
  Let \(\adv\) be a \((t, \qobs, \qp, \qv)\)-DH adversary, then 
  \(\Adv_{DBS}^{\text{DH}}(\adv) = \frac{1}{m^n}\).
\end{restatable}

The proof is found in \cref{ProofUWBDFresistance}.

