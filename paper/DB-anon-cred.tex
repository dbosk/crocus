\section{Distance-bounding anonymous credentials}%
\label{DB-anon-cred}

One protocol exists in the literature that provides \acp{PPK} with most of the 
desired properties described previously, ProProx~\cite{ProProx}\footnote{Note 
  that~\cite{ProProx} uses the abbreviation PoPoK, we prefer \acs{PPK} for 
  shorter notation.}.
ProProx is secure against a malicious verifier, but it provides \iac{PPK} 
protocol for quadratic residues (\ie protocols of the form \(\PPK[\alpha][a = 
  \alpha^2]\)), while in our context, we need \iac{PPK} protocol for discrete 
logarithms (\ie \(\PPK[\alpha][a = g^\alpha]\)) due to our choice of 
anonymous credentials whose desirable properties we list in
\cref{ZK-anon-cred}.%, which in turn is due to their \ac{PRF} for deriving identifiers from a long-term ID with unlinkability to the original ID but with proof of validity of this derivation. 
To realize this, we will now introduce such a protocol in order to enable us to have \ac{DB} anonymous credentials.

\subsection{Reattempting a distance-bounding Schnorr protocol}%
\label{DBSchnorr}

In the original \ac{DB} paper by \citet{DistanceBounding}, one of the distance-bounding protocol is based on the Schnorr identification scheme~\cite{Schnorr}.
However, this \ac{DB} Schnorr protocol was shown to be prone to distance hijacking~\cite{DistanceHijacking, TamarinDB}, in addition to not being secure against terrorist fraud.
We now propose another way to turn the Schnorr protocol into a
public-key \ac{DB} protocol which is secure against \ac{DBMF},
\ac{DBDF}, \ac{DBDH} and \ac{DBTF}.
The public-key property implies protection against an impersonating
verifier.

We present the protocol in \cref{SchnorrFigure}.
The group with generator \(g\) and order \(q\) are system parameters.
The private key \(\alpha\) with public key \(A = g^\alpha\) are generated once 
by the prover in the setup phase.

During one round, the prover generates a random nonce \(\rho\rgets \ZZ_q\), 
computes \(R\gets g^\rho\) and sends \(R\) to the verifier.
The verifier generates two challenges \(c_0\rgets \bin^k, c_1\rgets \bin^k\) 
and sends them to the prover.
The prover computes \(s_0\gets \rho - c_0\alpha, s_1\gets \rho - c_1\alpha\).
This is the main difference to the original Schnorr protocol: the verifier 
selects two challenges and the prover \emph{computes} two responses --- but 
still only \emph{one nonce}, \(\rho\).
(This is also different from Brands-Chaum, where the prover and verifier 
jointly construct \emph{one} challenge with \emph{one} response.)
We let \(|q| = \ceil{\log_2 q}\) denote the length of \(q\) in bits.
The verifier will request all \(|q|\) response-bits from one challenge (say 
\(s_b, b\in \bin\)) and only \(l > 0\) from the other (\(s_{1-b}\)).
Finally, the verifier has \(s_b\) and can authenticate the prover by checking 
if \(R = g^{s_b}A^{c_b}\).

The prover must know the responses for both challenges to successfully pass the 
\ac{DB} phase.
The reason for the two challenges but only one random nonce (change from 
Schnorr) is that knowing the responses to both means learning \(\alpha\) (for
\ac{DBTF}).
Bundling the authentication into the distance bounding phase (difference from 
Brands-Chaum) was done for \ac{DBDH},
and both adaptations together aim at \ac{DBMF} resistance. %reducing success of MF according to number of repetitions.

\begin{figure*}
  \centering
  \begin{tabular}{p{0.8\columnwidth}cp{0.8\columnwidth}}
    \(\DBSprove[g, q, \alpha, A = g^\alpha]\):
    & &
    \(\DBSverify[g, q, A]\):
    \\
    \midrule

    \multicolumn{3}{c}{\textbf{Setup}} \\

    \(\rho\rgets \ZZ_q, R\gets g^{\rho}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    % null
    & \(\ProtoSendLeft{c_0, c_1}\)
    & \(c_0\rgets \bin^k, c_1\rgets \bin^k\)
    \\

    \(s_0\gets \rho - c_0\alpha \pmod q\)
    &
    & \(b\rgets \bin\)
    \\

    \(s_1\gets \rho - c_1\alpha \pmod q\)
    &
    & Prepare \(B\in \bin^{|q|+l}\), with \(|q|\) bits set to \(b\).
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}: \(\forall i: 0\leq i < |q| + 
        l, j\gets 0\)} \\

%    % null
%    &
%    & Random delay
%    \\

    % null
    & \(\ProtoSendLeft{b_i}\)
    & \(b_i\gets B[i]\)
    \\

    \(r_i\gets s_{b_i}[jb_i + (i-j)(1-b_i)]\)
    & \(\ProtoSendRight{r_i}\)
    & Record \(\Delta t_i\)
    \\

    \(j \gets j + b_i\)
    &
    &
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Construct \(s_b\) as the concatenation of \(r_i\)'s for which \(b_i = 
      b\).
      Accept if \(R = g^{s_b} A^{c_b}\).
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSprove\leftrightarrow \DBSverify\) \ac{DB} Schnorr protocol for \(\PK[\alpha][A = g^\alpha]\).
    The protocol should be repeated in full to achieve the desired knowledge and distance-bounding errors.
  }%
  \label{SchnorrFigure}
\end{figure*}

\subsection{Security analysis}

The intuition behind the protocol security is as follows.
To achieve malicious-verifier zero-knowledge, choose \(k\) logarithmically with 
respect to the security parameter \(\lambda\) and repeat the protocol \(n\) 
times, such that the knowledge error, \(2^{-kn}\), becomes small enough.
This is also needed to decrease the success probability of some of adversaries 
presented below.

The \ac{DB} phase protects against distance fraud.
Once the prover has received \(l+1\) challenges set to \(b\), it knows that the 
remaining challenges must also be \(b\).
\Iac{DBDF} prover must thus wait for the challenge bit \(b_i\) before 
responding with \(r_i\) before at least \(l+1\) challenges.
Thus, the probability of successfully guessing the order of the challenge bits 
is \(2^{-(l+1)}\) per round in the worst case or, in total, \(2^{-(l+1)n}\).

The \ac{DB} phase also ensures that \iac{DBMF} adversary will fail the \ac{DB} 
phase for at least one round.
The verifier will send \(|q| + l < 2|q|\) challenges.
By replying, the prover reveals all the bits of either \(s_0\) or \(s_1\), but 
only \(l\) bits of the other.
The adversary now has two options.
First, the adversary can buffer \(l\) bits of both \(s_0, s_1\) by requesting 
them from the prover.
However, at this point the adversary must wait for the challenge bit 
\(b_{l+1}\) from the verifier and then relay that challenge to the prover to 
receive the correct \(r_i\) --- this relay will be detected.
The (better) alternative is to guess \(b\) and extract the \(|q|\) correct bits 
for this challenge from the prover.
Guessing \(b\) yields \(1/2\) probability \emph{per round} that the \ac{DBMF} 
adversary will guess it correctly.
Since we must execute the protocol \(n\) times, this is reduced to \(2^{-n}\).
The adversary can also guess the remaining \(|q|-l\) bits, which we will 
discuss more below.
Guessing these bits is independent of the rounds and can be estimated to be 
\(2^{-(|q|-l)}\) (more details below).
Thus the success probability of the \ac{DBMF} adversary is \emph{at most} 
\(2^{-n}+2^{-(|q|-l)}\).

The protocol is \ac{DBTF}-resistant, indeed, if the malicious prover gives both 
responses to the adversary, the adversary can compute his secret key.
In fact, this property is tied to the knowledge extractor used in the proof of 
the \ac{ZKPK} property of the Schnorr protocol.
The probability of success of \ac{DBTF} is thus reduced to guessing \(b\), \ie 
\(1/2\) per round or, in total, \(2^{-n}\).

The protocol is also secure against distance hijacking due to the fact
that it is the authentication bitstring that is used during the \ac{DB}
phase, not the challenge bitstring as in the protocol of Brands-Chaum.

Finally, it follows from the original Schnorr protocol that this is still 
\iac{PK} and \ac{ZK}.
The main concern is whether a malicious verifier can guess the remaining 
\(|q|-l\) bits after the protocol finished to compute the secret of the prover.
If we \emph{assume} that the adversary learning \(l > 0\) out of \(n\) bits is 
equivalent to the adversary learning nothing out of \(n-l\) bits, then the 
probability that the adversary succeeds is, as above, \(2^{-(|q|-l)}\).

\daniel{Not sure I follow exactly in the following.}
While the majority of \ac{DB} schemes are based on
shared secrets and thus assume an honest verifier, this limits the
inherent advantage of our public-key \ac{DB} scheme.
\sonja{verifier impersonating prover: vulnerability
  we introduce against public-key DB schemes, mitigated by limiting
  size of l (bits of other s). Trade-off: want long l for reducing
  success of guessing correct sequence of challenge bits, want short l
  for reducing success of guessing the other s and finding alpha}


\sonja{\subsection{Formal Verification} 
 verification with tamarin: there is no BC Schnorr in Tamarin,  [10]
assumed equivalence with Fiat-Shamir model. Not straightforward to
implement Schnorr in Tamarin due to a lack of expressiveness for
arithmetic needed to complement Diffie-Hellman. If not done now, left
for future work. }
