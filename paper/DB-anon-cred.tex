\section{Distance-bounding anonymous credentials}%
\label{DB-anon-cred}

One protocol exists in the literature that provides \acp{PPK} with most of the 
desired properties described previously, ProProx~\cite{ProProx}\footnote{Note 
  that~\cite{ProProx} uses the abbreviation PoPoK, we prefer \acs{PPK} for 
  shorter notation.}.
However, ProProx is secure against a malicious verifier and provides \iac{PPK} 
protocol for quadratic residues (\ie protocols of the form \(\PPK[\alpha][a = 
  \alpha^2]\)) while in our context, we need \iac{PPK} protocol for discrete 
logarithms (\ie \(\PPK[\alpha][a = g^\alpha]\)).
To realize this, we will now introduce such a protocol in order to enable us to have \ac{DB} anonymous credentials.

\subsection{Reattempting a distance-bounding Schnorr protocol}%
\label{DBSchnorr}

In the original \ac{DB} paper by \citet{DistanceBounding}, one of the distance-bounding protocol is based on the Schnorr identification scheme~\cite{Schnorr}.
However, this \ac{DB} Schnorr protocol was shown to be prone to distance hijacking~\cite{DistanceHijacking}, in addition to not being secure against terrorist fraud.
We now propose another way to turn the Schnorr protocol into a
public-key \ac{DB} protocol which is secure against \ac{DBMF},
\ac{DBDF}, \ac{DBDH} and \ac{DBTF}.
The public-key property implies protection against an impersonating
verifier.

We present the protocol in \cref{SchnorrFigure}.
The main difference to the original Schnorr protocol is that the prover commits 
to one random value but the verifier sends \emph{two challenges}.
This is also different from Brands-Chaum, where the prover and verifier jointly 
construct the challenge.
(We let \(|q| = \ceil{\log_2 q}\) denote the length of \(q\) in bits.)
The verifier will request all \(|q|\) response-bits from one challenge and only 
\(l > 0\) from the other.
The prover must know the responses for both challenges to successfully pass the 
\ac{DB} phase.

\begin{figure*}
  \centering
  \begin{tabular}{p{0.8\columnwidth}cp{0.8\columnwidth}}
    \(\DBSprove[g, q, \alpha, A = g^\alpha]\):
    & &
    \(\DBSverify[g, q, A]\):
    \\
    \midrule

    \multicolumn{3}{c}{\textbf{Setup}} \\

    \(\rho\rgets \ZZ_q, R\gets g^{\rho}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    % null
    & \(\ProtoSendLeft{c_0, c_1}\)
    & \(c_0\rgets \bin^k, c_1\rgets \bin^k\)
    \\

    \(s_0\gets \rho + c_0\alpha \pmod q\)
    &
    & \(b\rgets \bin\)
    \\

    \(s_1\gets \rho + c_1\alpha \pmod q\)
    &
    & Prepare \(B\in \bin^{|q|+l}\), with \(|q|\) bits set to \(b\).
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}: \(\forall i: 0\leq i < |q| + 
        l, j\gets 0\)} \\

%    % null
%    &
%    & Random delay
%    \\

    % null
    & \(\ProtoSendLeft{b_i}\)
    & \(b_i\gets B[i]\)
    \\

    \(r_i\gets s_{b_i}[jb_i + (i-j)(1-b_i)]\)
    & \(\ProtoSendRight{r_i}\)
    & Record \(\Delta t_i\)
    \\

    \(j \gets j + b_i\)
    &
    &
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Construct \(r = s_b\) as the concatenation of \(r_i\)'s for which \(b_i = 
      b\).
      Accept if \(R = g^r A^{c_b}\).
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSprove\leftrightarrow \DBSverify\) \ac{DB} Schnorr protocol for \(\PK[\alpha][A = g^\alpha]\).
    The protocol should be repeated in full to achieve the desired knowledge and distance-bounding errors.
  }%
  \label{SchnorrFigure}
\end{figure*}

\subsection{Security analysis}

The intuition behind the protocol security is as follows.
To achieve malicious-verifier zero-knowledge, choose \(k\) logarithmically with 
respect to the security parameter \(\lambda\) and repeat the protocol \(n\) 
times, such that the knowledge error, \(2^{-kn}\), becomes small enough.
This is also needed to decrease the success probability of some of adversaries 
presented below.

The \ac{DB} phase protects against distance fraud.
Once the prover has received \(l+1\) challenges set to \(b\), it knows that the 
remaining challenges must also be \(b\).
\Iac{DBDF} prover must thus wait for the challenge bit \(b_i\) before 
responding with \(r_i\) before at least \(l+1\) challenges.
Thus, the probability of successfully guessing the order of the challenge bits 
is \(2^{-(l+1)}\) per round in the worst case or, in total, \(2^{-(l+1)n}\).

The \ac{DB} phase also ensures that \iac{DBMF} adversary will fail the \ac{DB} 
phase for at least one round.
The verifier will send \(|q| + l < 2|q|\) challenges.
By replying, the prover reveals all the bits of either \(s_0\) or \(s_1\), but 
only \(l\) bits of the other.
The adversary now has two options.
First, the adversary can buffer \(l\) bits of both \(s_0, s_1\) by requesting 
them from the prover.
However, at this point the adversary must wait for the challenge bit 
\(b_{l+1}\) from the verifier and then relay that challenge to the prover to 
receive the correct \(r_i\) --- this relay will be detected.
The (better) alternative is to guess \(b\) and extract the \(|q|\) correct bits 
for this challenge from the prover.
Guessing \(b\) yields \(1/2\) probability \emph{per round} that the \ac{DBMF} 
adversary will guess it correctly.
Since we must execute the protocol \(n\) times, this is reduced to \(2^{-n}\).
The adversary can also guess the remaining \(|q|-l\) bits, for which the 
probability of success is \(2^{-(|q|-l)}\) (note that this is independent of 
the rounds).
Thus, the success probability of the \ac{DBMF} adversary is \emph{at most} 
\(2^{-n}+2^{-(|q|-l)}\).

The protocol is \ac{DBTF}-resistant, indeed, if the malicious prover gives both 
responses to the adversary, the adversary can compute his secret key.
In fact, this property is tied to the knowledge extractor used in the proof of 
the \ac{ZKPK} property of the Schnorr protocol.
The probability of success of \ac{DBTF} is thus reduced to guessing \(b\), \ie 
\(1/2\) per round or, in total, \(2^{-n}\).

The protocol is also secure against distance hijacking due to the fact
that it is the authentication bitstring that is used during the \ac{DB}
phase, not the challenge bitstring as in the protocol of Brands-Chaum.

Finally, a malicious verifier who wants to impersonate a prover can guess the 
remaining \(|q|-l\) bits after the protocol finished to compute the secret of 
the prover.
The probability that this succeeds is, as above, \(2^{-(|q|-l)}\).
