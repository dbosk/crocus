\section{Distance-bounding \aclp*{ZKPK} for discrete logarithms}%
\label{DB-anon-cred}

We will now introduce \iac{DB} protocol which is a \ac{ZKPK} for discrete 
logarithms.
Our protocol is an adaptation of the Schnorr identification 
scheme~\cite{Schnorr}, albeit different from that of 
\textcite{DistanceBounding} in the original \ac{DB} paper.
(That protocol was shown to be prone to distance 
hijacking~\cite{DistanceHijacking,TamarinDB} and was not secure against 
terrorist fraud.)
We propose another way to turn the Schnorr protocol into a public-key \ac{DB} 
protocol which is \iac{ZKPK} that is secure against \ac{DBMF}, \ac{DBDF}, 
\ac{DBDH} and \ac{DBTF}.
This yields strong privacy properties and protection against a malicious, 
impersonating verifier.

We also deviate from the normal technique of one-bit challenges and responses 
otherwise used in \ac{DB} protocols.
\Textcite{UWBPR} proposed a secure encoding for the physical 
layer which removes the requirement of only using single-bit challenges and 
responses for distance bounding.
However, their protocol only works for relay attacks and cannot handle distance 
fraud.
This is due to a requirement of the protocol that the prover and verifier must 
share a secret, and thus must be mutually trusted.

We will first present our version of the \ac{DB} Schnorr protocol for the 
mutual-trust case, where the prover and verifier have a pre-shared secret.
Then we will adapt it by introducing \iac{AKE}.
The authentication in this \ac{AKE} will leverage that our protocol is \iac{DB} 
\ac{ZKPK} for discrete logarithms.
If the \ac{AKE} is based on discrete logarithms we can prove the distance bound 
while we authenticate the key.
This allows us to embed this protocol into tamper resistant hardware to provide 
security against malicious provers.


\subsection{Reattempting a distance-bounding Schnorr protocol}%
\label{DBSchnorr}

Thanks to \textcite{UWBPR} we can keep the Schnorr protocol 
almost as is, relays (\ac{DBMF}, \ac{DBDH}) are dealt with on the physical 
layer.
The only concern, for now, is \acl{DBTF}.
(We deal with \acl{DBDF} later.)

We present the protocol in \cref{SchnorrFigure}.
The (cyclic) group with generator \(g\) and order \(q\) are system parameters.
The private key \(\alpha\) with public key \(A = g^\alpha\) are generated once by the prover in the setup phase.
Let \(\UWBPR\) be the protocol of \textcite{UWBPR}.
Further, let
\(\UWBPRsend[_k][m]\) denote sending a message~\(m\) with the shared key~\(k\),
\(m'\gets \UWBPRrecv_k\) denote receiving a message~\(m'\) with shared 
key~\(k\) and finally
\(\Delta t\gets \UWBPRtime\) denote the time between the last \(\UWBPRsend\) 
and \(\UWBPRrecv\) operations.

\begin{figure*}
  \centering
  \small
  \setlength{\ProtoArrowLength}{0.07\linewidth}
  \begin{tabular}{p{0.40\linewidth}cp{0.40\linewidth}}
    \(\DBSprove[\sk, g, q, \alpha, A = g^\alpha]\):
    & &
    \(\DBSverify[\sk, g, q, A]\):
    \\
    \midrule

    \multicolumn{3}{c}{\textbf{Setup}} \\

    Load \(\sk\) into \(\UWBPR\)
    &
    & Load \(\sk\) into \(\UWBPR\)
    \\

    \(\rho\rgets \ZZ_q, R\gets g^{\rho}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    \(s_1\gets \rho - c_1\alpha \pmod q\)
    & \(\ProtoSendLeft{c_1, \dotsc, c_k}\)
    & \(c_1\rgets \bin^k, \dotsc, c_k\rgets \bin^k\)
    \\

    \vdots
    &
    &
    \\[-1em]

    \(s_k\gets \rho - c_k\alpha \pmod q\)
    &
    &
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}} \\

    \text{Ready}
    & \ProtoSendRight{\text{Ready}}
    & \\

%    % null
%    &
%    & Random delay
%    \\

    % null
    & \(\ProtoSendLeft{i}\)
    & \(i\rgets \{1, \dotsc, k\}\), start clock
    \\

    Fetch \(s_i\)
    & \(\ProtoSendRight{s_i}\)
    & Stop clock, record \(\Delta t\)
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Accept if \(R = g^{s_i} A^{c_i}\) and \(\Delta t < t_{\max}\).
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSprove\leftrightarrow \DBSverify\) 
    protocol instantiating \(\PK[\alpha][A = g^\alpha]\).
    Each transmission (arrow in the diagram) uses \(\UWBPR\).
    The protocol should be repeated \(n\) times to achieve the desired 
    soundness and distance-bounding errors.
  }%
  \label{SchnorrFigure}
\end{figure*}

During one round, in the setup phase, the prover commits to a random nonce: 
more precisely he chooses \(\rho\rgets \ZZ_q\) uniformly at random, computes 
\(R\gets g^\rho\) and sends \(R\) to the verifier.
The verifier generates \(k\) challenges \(c_1\rgets \bin^k, \dotsc, c_k\rgets 
  \bin^k\) (bit strings of length \(k\)) and sends them to the prover.
The prover computes one response per challenge, \(s_1\gets \rho - c_1\alpha, 
  \dotsc, s_k\gets \rho - c_k\alpha\).
This step is the main difference to the original Schnorr protocol: the verifier 
selects several challenges and the prover computes several responses --- but 
still only use \emph{one nonce}, \(\rho\).
This is needed for \ac{DBTF} resistance.
This is also different from the original Brands-Chaum protocol, in which the 
prover and verifier jointly construct \emph{one} challenge with \emph{one} 
response.

In the \ac{DB} phase, the prover notifies the verifier that he has computed 
\(s_1, \dotsc, s_k\).
The verifier chooses one of the challenges, \(i\), uniformly randomly and sends 
it as a challenge to the prover and starts measuring the time of flight.
The prover replies with \(s_i\).
The verifier stops the measurement and verifies that \(R = g^{s_i}A^{c_i}\) and 
that the time of flight was within \(t_{\max}\) (determined from the allowed 
  distance).

This protocol must be repeated \(n\) times.

\subsection{Security analysis}

The intuition behind the protocol security is as follows.
The prover must know the responses for all challenges to successfully pass the 
\ac{DB} phase.
The reason for having several challenges but only one random nonce is that 
knowing at least two responses means learning \(\alpha\).
This gives us the incentives that prevent \ac{DBTF}.
Bundling the authentication into the distance-bounding phase (difference from 
Brands-Chaum) prevents \ac{DBDH}.
We do not consider \ac{DBDF} here; since the prover knows the key~\(\sk\), she 
can do \iac{DBEDLC} attack to reduce the distance.
(We will solve this problem in the next section.)
However, the properties of \(\UWBPR\) ensures \ac{DBMF} resistance.

The \(\UWBPR\) prevents \iac{DBMF} adversary from performing a 
distance-reduction through \iac{DBEDLC} attack.
Thus, any relaying will be detected.
The adversary could guess the challenge bit \(b\), request \(s_b\) from the 
prover and guess \(s_{1-b}\).
The success probability of this is \(\frac{1}{2} + \frac{1}{q}\) per round, 
thus \((\frac{q + 2}{2q})^n\) in total.

The protocol is also secure against distance hijacking due to the fact that the 
authenticating bit string is used during the \ac{DB} phase, not the challenge 
bit string, as is the case for the original protocol of Brands-Chaum.
Thus the probability of success is equivalent of a collision for the responses 
for the chosen challenge --- in each round.

\Ac{DBDH} requires that the adversary finds a collision between his response 
and that of the honest prover.
\dots

Finally, it follows from the original Schnorr protocol that this is still 
\ac{ZK} and \iac{PK} with soundness error \(2^{-kn}\).
To achieve malicious-verifier zero-knowledge, choose \(k\) logarithmic in the 
security parameter \(\lambda\) and repeat the protocol \(n\) times.

\daniel{I should prove this for the composed protocol, I should check the details with Douglas.}

\subsection{Achieving \acl{DBDF} and \acl{DBTF} resistance}

\Acl{DB} protocols requires hardware implementations.
We will use a trusted hardware implementation to overcome the limitation of 
\textcite{UWBPR}, \ie that the prover and verifier be mutually trusted.
This will also require \iac{PKI} to overcome the shared-key requirement and for 
a verifier to be able verify the hardware of a prover.

The \ac{DB} phase protects against distance fraud.
Once the prover has received \(l+1\) challenges set to \(b\), it knows that the remaining challenges must also be \(b\).
\Iac{DBDF} prover must thus wait for the challenge bit \(b_i\) before responding with \(r_i\) for \(l+1\) challenges.
Thus, the probability of successfully guessing the order of the challenge bits is \(2^{-(l+1)}\) per round or, in total, \(2^{-(l+1)n}\).

The protocol is \ac{DBTF}-resistant.
Indeed, if the malicious prover gives both responses to the accomplice, the 
accomplice can compute his secret key.
The probability of success of \ac{DBTF} is thus reduced to guessing \(b\), \ie \(1/2\) per round or, in total, \(2^{-n}\).

\subsection{Formal Verification}

We formally verified these properties with Tamarin~\cite{meier2013tamarin}.
Thanks to recent work by \textcite{TamarinDB}, all the common properties for 
\ac{DB} protocols (except \ac{DBTF}) can be characterized with a 
causality-based definition relying only on the order of messages.
The whole Tamarin specification for our protocol is provided in 
\cref{apdx:tamarin-spec}, with a short discussion of the modeling choices that 
we have made.
It contains a specification of the distance-bounding protocol described 
previously, a definition of the soundness and correctness properties that 
ensure the protocol actually produces the expected result, and a definition of 
the security properties we want to ensure.


