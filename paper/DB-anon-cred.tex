\section{Distance-bounding \aclp*{ZKPK} for discrete logarithms}%
\label{DB-anon-cred}

We will now introduce \iac{DB} protocol which is a \ac{ZKPK} for discrete 
logarithms.
Our protocol is an adaptation of the Schnorr identification 
scheme~\cite{Schnorr}, albeit different from that of 
\textcite{DistanceBounding} in the original \ac{DB} paper\footnote{%
  The \citeauthor{DistanceBounding} protocol was shown to be prone to distance 
  hijacking~\cite{DistanceHijacking,TamarinDB} and was not secure against 
  terrorist fraud.
} and that of \textcite{Bussard-Bagga}\footnote{%
  The \citeauthor{Bussard-Bagga} protocol was also shown to be 
  vulnerable~\cite{Bussard-Bagga-attack}.
  Although this time, the protocol could not protect against \ac{DBTF} and 
  \ac{DBDF} as it claimed.
}.
We propose another way to turn the Schnorr protocol into a public-key \ac{DB} 
protocol which is \iac{ZKPK} that is secure against \ac{DBMF}, \ac{DBDF}, 
\ac{DBDH} and \ac{DBTF}.
This yields strong privacy properties and protection against a malicious, 
impersonating verifier.

We also deviate from the normal technique of one-bit challenges and responses 
otherwise used in \ac{DB} protocols.
\Textcite{UWBPR} proposed a secure encoding for the physical 
layer which removes the requirement of only using single-bit challenges and 
responses for distance bounding.
However, their protocol only works for relay attacks and cannot handle distance 
fraud.
This is due to a requirement of the protocol that the prover and verifier must 
share a secret, and thus must be mutually trusted.

We will first present our version of the \ac{DB} Schnorr protocol for the 
mutual-trust case, where the prover and verifier have a pre-shared secret.
Then we will adapt it by introducing \iac{AKE}.
The authentication in this \ac{AKE} will leverage that our protocol is \iac{DB} 
\ac{ZKPK} for discrete logarithms.
If the \ac{AKE} is based on discrete logarithms we can prove the distance bound 
while we authenticate the key.
This allows us to embed this protocol into tamper resistant hardware to provide 
security against malicious provers.


\subsection{Reattempting a distance-bounding Schnorr protocol}%
\label{DB-Schnorr}

Thanks to \textcite{UWBPR} we can keep the Schnorr protocol 
almost as is, relays (\ac{DBMF}, \ac{DBDH}) are dealt with on the physical 
layer.
The only concern, for now, is \acl{DBTF}.
(We deal with \acl{DBDF} later.)

We present the protocol in \cref{SchnorrFigure}.
The (cyclic) group with generator \(g\) and order \(q\) are system parameters.
The private key \(\alpha\) with public key \(A = g^\alpha\) are generated once by the prover in the setup phase.
Let \(\UWBPR\) be the protocol of \textcite{UWBPR}.
Further, let
\(\UWBPRsend[_k][m]\) denote sending a message~\(m\) with the shared key~\(k\),
\(m'\gets \UWBPRrecv_k\) denote receiving a message~\(m'\) with shared 
key~\(k\) and finally
\(\Delta t\gets \UWBPRtime\) denote the time between the last \(\UWBPRsend\) 
and \(\UWBPRrecv\) operations.

\begin{figure*}
  \centering
  \small
  \setlength{\ProtoArrowLength}{0.07\linewidth}
  \begin{tabular}{p{0.40\linewidth}cp{0.40\linewidth}}
    \(\DBSprove[\sk, g, q, \alpha, A = g^\alpha]\):
    & &
    \(\DBSverify[\sk, g, q, A]\):
    \\
    \midrule

    \multicolumn{3}{c}{\textbf{Setup}} \\

    Load \(\sk\) into \(\UWBPR\)
    &
    & Load \(\sk\) into \(\UWBPR\)
    \\

    \(\rho\rgets \ZZ_q, R\gets g^{\rho}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    \(s_1\gets \rho - c_1\alpha \pmod q\)
    & \(\ProtoSendLeft{c_1, \dotsc, c_k}\)
    & \(c_1\rgets \bin^k, \dotsc, c_k\rgets \bin^k\)
    \\

    \vdots
    &
    &
    \\[-1em]

    \(s_k\gets \rho - c_k\alpha \pmod q\)
    &
    &
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}} \\

    \text{Ready}
    & \ProtoSendRight{\text{Ready}}
    & \\

%    % null
%    &
%    & Random delay
%    \\

    % null
    & \(\ProtoSendLeft{i}\)
    & \(i\rgets \{1, \dotsc, k\}\), start clock
    \\

    Fetch \(s_i\)
    & \(\ProtoSendRight{s_i}\)
    & Stop clock, record \(\Delta t\)
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Accept if \(R = g^{s_i} A^{c_i}\) and \(\Delta t < t_{\max}\).
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSprove\leftrightarrow \DBSverify\) 
    protocol instantiating \(\PK[\alpha][A = g^\alpha]\).
    Each transmission (arrow in the diagram) uses \(\UWBPR\).
    The protocol should be repeated \(n\) times to achieve the desired 
    soundness and distance-bounding errors.
  }%
  \label{SchnorrFigure}
\end{figure*}

During one round, in the setup phase, the prover commits to a random nonce: 
more precisely he chooses \(\rho\rgets \ZZ_q\) uniformly at random, computes 
\(R\gets g^\rho\) and sends \(R\) to the verifier.
The verifier generates \(k\) challenges \(c_1\rgets \bin^k, \dotsc, c_k\rgets 
  \bin^k\) (bit strings of length \(k\)) and sends them to the prover.
The prover computes one response per challenge, \(s_1\gets \rho - c_1\alpha, 
  \dotsc, s_k\gets \rho - c_k\alpha\).
This step is the main difference to the original Schnorr protocol: the verifier 
selects several challenges and the prover computes several responses --- but 
still only use \emph{one nonce}, \(\rho\).
This is needed for \ac{DBTF} resistance.
This is also different from the original Brands-Chaum protocol, in which the 
prover and verifier jointly construct \emph{one} challenge with \emph{one} 
response.

In the \ac{DB} phase, the prover notifies the verifier that he has computed 
\(s_1, \dotsc, s_k\).
The verifier chooses one of the challenges, \(i\), uniformly randomly and sends 
it as a challenge to the prover and starts measuring the time of flight.
The prover replies with \(s_i\).
The verifier stops the measurement and verifies that \(R = g^{s_i}A^{c_i}\) and 
that the time of flight was within \(t_{\max}\) (determined from the allowed 
  distance).

This protocol must be repeated \(n\) times.

\subsection{\Acl*{ZK} and \acl*{PK}}

The main difference between this protocol and the Schnorr protocol is that we 
have the prover compute responses for \(k\) different challenges, \(c_1, 
  \dotsc, c_k\).
However, in the authentication step, the verifier chooses only one of those 
challenges.
From the simulator's (and extractor's) perspective, there is no difference 
whether the verifier first chooses \(k\) and then chooses one of those \(k\) 
challenges, or if the verifier chooses the one challenge directly;
the distribution is the same, \(\frac{k}{n}\times \frac{1}{k} = \frac{1}{n}\).
Therefore the standard proof for Schnorr as a malicious-verifier \ac{ZKPK} 
protocol with soundness error \(2^{-kn}\) still 
holds~\cite[\eg][]{OnSigmaProtocols}.
(We note that \(k\), which is also the length of the challenge bit string, must 
be logarithmic in the security parameter, \(\lambda\), for a malicious 
verifier.)

\subsection{\acs*{DBMF}, \acs*{DBDH} and \acs*{DBTF} resistance}

The intuition behind the protocol security is as follows.
The prover must know the responses for all challenges to successfully pass the 
\ac{DB} phase.
The reason for having several challenges but only one random nonce is that 
knowing at least two responses means learning the secret~\(\alpha\).
This gives us the incentives that prevent \ac{DBTF}.
(We also need it for \ac{DBMF}.)
Bundling the authentication into the distance-bounding phase (difference from 
Brands-Chaum) prevents \ac{DBDH}.
We do not consider \ac{DBDF} here; since the prover knows the key~\(\sk\), she 
can do \iac{DBEDLC} attack to reduce the distance.
(We will solve this problem further down.)
However, the properties of \(\UWBPR\) and the unpredictability of the 
challenges ensures \ac{DBMF} resistance (since then the prover is honest).

The \(\UWBPR\) prevents \iac{DBMF} adversary from performing a 
distance-reduction through \iac{DBEDLC} attack~\cite{UWBPR}.
Thus, any relaying will be detected, \ie this justifies \cref{TaintedMF}.

\daniel{Still intuition, we need to use the formal definition of security 
  above.}
\begin{theorem}[\acs*{DBMF} resistance]
  Let \(\adv\) be a \((t, \qobs, \qp, \qv)\)-MF adversary, then 
  \(\Adv_{\DBS}^{\text{MF}}(\adv) = \left(\frac{1}{k}+\frac{1}{q}\right)^n\), 
  where \(k, q\) are as in \cref{DB-Schnorr}.
\end{theorem}

\begin{proof}
  The adversary has two options:
  \begin{enumerate*}
  \item guess which challenge the verifier will use and request the correct 
    response from the prover, this yields success with probability 
    \(\frac{1}{k}\);
  \item guess the response, this yields success with probability 
    \(\frac{1}{q}\).
  \end{enumerate*}
  The total success probability is \(\frac{1}{k} + \frac{1}{q}\) per round, 
  thus \(\left(\frac{1}{k}+\frac{1}{q}\right)^n\) in total per protocol 
  session.
\end{proof}

The protocol is also secure against distance hijacking due to the fact that the 
authenticating bit string is used during the \ac{DB} phase, not the challenge 
bit string, as is the case for the original protocol of Brands-Chaum.
\Ac{DBDH} requires that the adversary finds a collision between his response 
and that of the honest prover.
Thus the probability of success is equivalent to a collision for the responses 
for the chosen challenge --- in each round.

\daniel{Still intuition, we need to use the formal definition of security 
  above.}
\begin{theorem}[\acs*{DBDH} resistance]
  Let \(\adv\) be a \((t, \qobs, \qp, \qv)\)-DH adversary, then 
  \(\Adv_{DBS}^{\text{DH}}(\adv) = \negl\).
\end{theorem}

\begin{proof}
  The honest prover will choose \(\rho\) such that \(R = g^\rho\).
  The adversary can send his own \(R' = g^{\rho'}\) to the verifier, or let 
  \(R' = R\) to not interfere.

  The verifier will choose \(c_1, \dotsc, c_k\).
  The adversary can send his own \(c_1', \dotsc, c_k'\) to the prover, or let 
  \(c_1' = c_1, \dotsc, c_k' = c_k\) to not interfere.

  The verifier will send its challenge \(i\), the prover will reply with \(s_i 
    = \rho - c_i' \alpha\).
  The verifier will check that \(R' = g^{s_i} A^{c_i}\).

  This yields that \(R' = g^{\rho'}\) should equal \(g^{s_i} A'^{c_i} = g^{\rho 
      - c_i' \alpha} (g^{\alpha'})^{c_i} = g^{\rho - c_i' \alpha + c_i 
      \alpha'}\).
  Both \(\rho\) and \(\alpha\) are unknown to the adversary and the adversary 
  cannot choose \(c_i\).
  The adversary needs \(\rho' = \rho - c_i' \alpha + c_i \alpha'\).
  Let \(\rho'\) and \(c_i'\) be fixed (say 0), then we have that \(\alpha' = 
    \rho c_i^{-1}\).
  We thus have that
  \(\Adv_{\DBS}^{\text{DH}}(\adv) = \Prob{\rho' - c_i \alpha' = \rho - c_i' 
      \alpha} = \frac{1}{q}\),
  which concludes the proof.
\end{proof}

The last property is \ac{DBTF}.
The protocol is \ac{DBTF} resistant.
Indeed, if the malicious prover gives both responses to the accomplice, the 
accomplice can compute his secret key.
And any help will increase the probability of success of future attempts.

\daniel{Still intuition, we need the formal definition of security above.}
\begin{theorem}[\acs*{DBTF} resistance]
  \dots
\end{theorem}

\begin{proof}
  Assume that there is an algorithm~\(\adv\) that can authenticate without the 
  provers help with non-negligible advantage~\(\epsilon < \frac{1}{2}\), \ie 
  the success probability is \(\frac{1}{2}+\epsilon\).
  The probability that \(\adv\) predicts the challenge is \(\frac{1}{2}\).
  Since \(\epsilon\) is non-negligible, there is some case for which \(\adv\) 
  knows both responses.
  In that case \(\adv\) can simply compute the secret and impersonate with 
  probability \(1\) forever, which contradicts our assumption about 
  \(\epsilon\).
\end{proof}

\subsection{\Iacs*{DBDF} resistant protocol}

\Acl{DB} protocols requires hardware implementations.
We will use a trusted hardware implementation to overcome the limitation of 
\textcite{UWBPR}, \ie that the prover and verifier be mutually trusted.
We will need \iac{PKI} for the verifier to verify the trusted hardware.
We will leverage this \ac{PKI} to overcome the shared-key requirement.
With \iac{PKI} based on discrete logarithms we will be able to perform \iac{DB} 
\ac{ZKPK} which \emph{simultaneously} proves
\begin{enumerate*}
\item that the protocol is run by trusted hardware,
\item that that trusted hardware is within proximity,
\item that some \ac{ZKPK} statement about some discrete logarithms holds, and
\item that that knowledge is within proximity.
\end{enumerate*}

We will now introduce an extended protocol, \(\DBSHW\), which represents the 
secure hardware implementation.
\Cref{DBSHW-overview} presents an overview.

\begin{figure*}
  \centering
  \small
  \setlength{\ProtoArrowLength}{0.07\linewidth}
  \begin{tabular}{p{0.40\linewidth}cp{0.40\linewidth}}
    \(\HWprove[g, q, \alpha]\):
    & &
    \(\HWverify[g, q, A]\):
    \\
    \midrule

    Static \(\sk_P, \cert_P\colon \pk_P = \hat g^{\sk_P}\)
    &
    & \(\sk_V, \pk_V = \hat g^{\sk_V}\)\\

    \midrule
    \multicolumn{3}{c}{\textbf{Pre-setup, authenticated key agreement}} \\

    \(\cert_P\)
    & \(\ProtoSendRight{\cert_P}\)
    & \(k \gets \pk_P^{\sk_V}\)
    \\

    \(k \gets \pk_V^{\sk_P}\)
    & \(\ProtoSendLeft{\pk_V}\)
    & \(\pk_V\)
    \\


    \midrule
    \multicolumn{3}{c}{\textbf{Setup}} \\

    Load \(k\) into \(\UWBPR\)
    &
    & Load \(k\) into \(\UWBPR\)
    \\

    \(\rho, \hat\rho \rgets \ZZ_q, R\gets g^{\rho} g^{\hat\rho}\)
    & \(\ProtoSendRight{R}\)
    & \(\hat A\gets A \pk_P\)
    \\

    \(s_1\gets \rho - c_1\alpha \pmod q\)
    & \(\ProtoSendLeft{c_1, \dotsc, c_k}\)
    & \(c_1\rgets \bin^l, \dotsc, c_m\rgets \bin^l\)
    \\

    \(\hat s_1\gets \hat\rho - c_1\sk_P \pmod q\)
    &
    &
    \\

    \vdots
    &
    &
    \\[-1em]

    \(s_m\gets \rho - c_m\alpha \pmod q\)
    &
    &
    \\

    \(\hat s_m\gets \hat\rho - c_m\sk_P \pmod q\)
    &
    &
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}} \\

    \text{Ready}
    & \ProtoSendRight{\text{Ready}}
    & \\

    % null
    & \(\ProtoSendLeft{i}\)
    & \(i\rgets \{1, \dotsc, m\}\), start clock
    \\

    Fetch \(s_i, \hat s_i\)
    & \(\ProtoSendRight{s_i, \hat s_i}\)
    & Stop clock, record \(\Delta t\)
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Accept if \(R =  \hat A^{c_i} g^{s_i} \hat g^{\hat s_i}\) and \(\Delta t 
      < t_{\max}\).
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSHW\) protocol instantiating 
    \(\PK[\alpha][A = g^\alpha]\).
    Each transmission (arrow in the diagram) uses \(\UWBPR\).
    The protocol should be repeated \(n\) times to achieve the desired 
    soundness and distance-bounding errors.
  }%
  \label{DBSHW-overview}
\end{figure*}

The \(\DBSHW\) secure hardware device must contain a (static) private 
key~\(\sk_P\) (for the prover, \(\sk_V\) for the verifier) with a digital 
certificate~\(\cert_P\) (and \(\cert_V\)) for the public key~\(\pk_P\) (and 
\(\pk_V\)).

\paragraph*{Pre-setup}

The pre-setup phase consists of an authenticated key agreement.
We use the static \ac{DHKE} to simplify the explanation, any authenticated key 
agreement protocol based on discrete logarithms can be used.
The prover and verifier exchange certificates, \(\cert_P\) and \(\cert_V\), and 
compute the agreed key~\(k = \pk_V^{\sk_P} = \pk_P^{\sk_V}\).
If the prover's certificate is invalid, the protocol aborts.

\paragraph*{Setup}

The setup phase is similar to \(\DBS\) (\cref{SchnorrFigure}).
\(\DBS\) performs \(\PK[\alpha][A = g^\alpha]\) whereas \(\DBSHW\) must perform 
\(\PK[\alpha, \sk_P][\hat A = g^\alpha \hat g^{\sk_P}]\).
\daniel{Or is it better to do \(\PK[\alpha, \sk_P][A = g^\alpha \land \hat A = 
    \hat g^{\sk_P}]\)?}
They use the agreed upon key~\(k\) as the key for \(\UWBPR\).

The prover chooses \(\rho, \hat\rho\rgets \ZZ_q\) and computes \(R\gets g^\rho 
  \hat g^{\hat\rho}\).
The verifier computes \(\hat A\gets A \pk_P\), where \(A\) is the value for 
which the prover must prove knowledge of the discrete logarithm.

The verifier chooses \(m\) challenges of length \(l\), \(c_1\rgets \bin^l, 
  \dotsc, c_m\gets \bin^l\), and sends these to the prover.
The prover computes responses~\(s_i\gets \rho - c_i\alpha\) and \(\hat s\gets 
  \hat\rho - c_i\sk_P\) for \(i\in \{1, \dotsc, m\}\).

\paragraph*{Distance bounding}

The verifier decides which of the \(m\) challenges to use, \(i\rgets \{1, 
  \dotsc, m\}\), sends its decision~\(i\) to the prover and starts its clock.
The prover instantly replies with the pre-computed \(s_i, \hat s_i\).
Note that \(s_i, \hat s_i\) must be sent as a concatenation in \emph{one} 
\(\UWBPR\) reply.
The verifier stops the clock and records the round-trip time~\(\delta t\).

\paragraph*{Verification}

The verifier checks if \(R = \hat A^{c_i} g^{s_i} \hat g^{\hat s_i}\) and that 
the round-trip time \(\delta t < t_{\max}\) does not exceed the 
limit~\(t_{\max}\).


\subsection{\acs*{DBDF} resistance}

This protocol uses the \ac{DBMF} resistance of \(\DBS\) to ensure \ac{DBDF} 
resistance against a malicious prover.
The trusted hardware uses the authenticated key agreement to establish the 
shared secret \(k\), thus a verifier prevents a malicious prover from learning 
\(k\) --- the main limit of~\cite{UWBPR}.

\subsection{Formal verification}

We formally verified these properties with Tamarin~\cite{meier2013tamarin}.
Thanks to recent work by \textcite{TamarinDB}, all the common properties for 
\ac{DB} protocols (except \ac{DBTF}) can be characterized with a 
causality-based definition relying only on the order of messages.
The whole Tamarin specification for our protocol is provided in 
\cref{apdx:tamarin-spec}, with a short discussion of the modeling choices that 
we have made.
It contains a specification of the distance-bounding protocol described 
previously, a definition of the soundness and correctness properties that 
ensure the protocol actually produces the expected result, and a definition of 
the security properties we want to ensure.

