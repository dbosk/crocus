\section{Distance-bounding \ac*{ZKPK} for discrete logarithms}%
\label{DB-anon-cred}

We will now introduce \iac{DB} protocol which is a \ac{ZKPK} for discrete 
logarithms.
Our protocol is an adaptation of the Schnorr identification 
scheme~\cite{Schnorr}, albeit different from that of 
\textcite{DistanceBounding} in the original \ac{DB} paper.
(That protocol was shown to be prone to distance 
hijacking~\cite{DistanceHijacking,TamarinDB} and was not secure against 
terrorist fraud.)
We propose another way to turn the Schnorr protocol into a public-key \ac{DB} 
protocol which is \iac{ZKPK} that is secure against \ac{DBMF}, \ac{DBDF}, 
\ac{DBDH} and \ac{DBTF}.
This yields strong privacy properties and protection against a malicious, 
impersonating verifier.

We also deviate from the normal technique of one-bit challenges and responses 
otherwise used in \ac{DB} protocols.
\Textcite{UWBPR} proposed a secure encoding for the physical 
layer which removes the requirement of only using single-bit challenges and 
responses for distance bounding.
However, their protocol only works for relay attacks and cannot handle distance 
fraud.
This is due to a requirement of the protocol that the prover and verifier must 
share a secret, and thus must be mutually trusted.

We will first present our version of the \ac{DB} Schnorr protocol for the 
mutual-trust case, where the prover and verifier have a pre-shared secret.
Then we will adapt it by introducing \iac{AKE}.
The authentication in this \ac{AKE} will leverage that our protocol is \iac{DB} 
\ac{ZKPK} for discrete logarithms.
If the \ac{AKE} is based on discrete logarithms we can prove the distance bound 
while we authenticate the key.
This allows us to embed this protocol into tamper resistant hardware to provide 
security against malicious provers.


\subsection{Reattempting a distance-bounding Schnorr protocol}%
\label{DBSchnorr}

Thanks to \textcite{UWBPR} we can keep the Schnorr protocol 
almost as is, relays (\ac{DBMF}, \ac{DBDH}) are dealt with on the physical 
layer.
The only concern, for now, is \acl{DBTF}.
(We deal with \acl{DBDF} later.)

We present the protocol in \cref{SchnorrFigure}.
The (cyclic) group with generator \(g\) and order \(q\) are system parameters.
The private key \(\alpha\) with public key \(A = g^\alpha\) are generated once by the prover in the setup phase.
Let \(\UWBPR\) be the protocol of \textcite{UWBPR}.
Further, let
\(\UWBPRsend[_k][m]\) denote sending a message~\(m\) with the shared key~\(k\),
\(m'\gets \UWBPRrecv_k\) denote receiving a message~\(m'\) with shared 
key~\(k\) and finally
\(\Delta t\gets \UWBPRtime\) denote the time between sending and receiving.

\begin{figure*}
  \centering
  \small
  \setlength{\ProtoArrowLength}{0.07\linewidth}
  \begin{tabular}{p{0.40\linewidth}cp{0.40\linewidth}}
    \(\DBSprove[k, g, q, \alpha, A = g^\alpha]\):
    & &
    \(\DBSverify[k, g, q, A]\):
    \\
    \midrule

    \multicolumn{3}{c}{\textbf{Setup}} \\

    Load \(k\) into \(\UWBPR\)
    &
    & Load \(k\) into \(\UWBPR\)
    \\

    \(\rho\rgets \ZZ_q, R\gets g^{\rho}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    \(s_0\gets \rho - c_0\alpha \pmod q\)
    & \(\ProtoSendLeft{c_0, c_1}\)
    & \(c_0\rgets \bin^k, c_1\rgets \bin^k\)
    \\

    \(s_1\gets \rho - c_1\alpha \pmod q\)
    &
    &
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}} \\

    \text{Ready}
    & \ProtoSendRight{\text{Ready}}
    & \\

%    % null
%    &
%    & Random delay
%    \\

    % null
    & \(\ProtoSendLeft{b}\)
    & \(b\rgets \bin\)
    \\

    Fetch \(s_b\)
    & \(\ProtoSendRight{s_b}\)
    & Record \(\Delta t\)
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Accept if \(R = g^{s_b} A^{c_b}\).
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSprove\leftrightarrow \DBSverify\) 
    protocol instantiating \(\PK[\alpha][A = g^\alpha]\).
    Each transmission (arrow in the diagram) uses \(\UWBPR\).
    The protocol should be repeated in full to achieve the desired soundness 
    and distance-bounding errors.
  }%
  \label{SchnorrFigure}
\end{figure*}

During one round, in the setup phase, the prover commits to a random nonce: 
more precisely he chooses \(\rho\rgets \ZZ_q\) uniformly at random, computes 
\(R\gets g^\rho\) and sends \(R\) to the verifier.
The verifier generates two challenges \(c_0\rgets \bin^k, c_1\rgets \bin^k\) and sends them to the prover.
The prover computes \(s_0\gets \rho - c_0\alpha, s_1\gets \rho - c_1\alpha\).
This step is the main difference to the original Schnorr protocol: the verifier selects two challenges and the prover computes two responses --- but still only \emph{one nonce}, \(\rho\).
This is also different from the original Brands-Chaum protocol, in which the 
prover and verifier jointly construct \emph{one} challenge with \emph{one} 
response.

In the \ac{DB} phase, the prover notifies the verifier that he has computed 
\(s_0, s_1\).
The verifier chooses one bit, \(b\), uniformly randomly and sends it as a 
challenge to the prover and starts measuring the time of flight.
The prover replies with \(s_b\).
The verifier stops the measurement and verifies that \(R = g^{s_b}A^{c_b}\).

\subsection{Security analysis}

The prover must know the responses for both challenges to successfully pass the \ac{DB} phase.
The reason for the two challenges but only one random nonce is that knowing the responses to both means learning \(\alpha\).
This allows us to prevent \ac{DBTF}.
Bundling the authentication into the distance-bounding phase (difference from Brands-Chaum) prevents \ac{DBDH}, and both adaptations together aim at \ac{DBMF} resistance. %reducing success of MF according to number of repetitions.
The reason we use secret sharing and not \(s_b\) directly, is to bound the \(l\) bits the verifier must learn of \(s_{1-b}\).
Without secret sharing, the verifier learns \(l\) bits of \(s_{1-b}\), but with secret sharing the verifier learns \(l\) bits of \emph{one share}.
Thus, we still have information theoretic security for \(s_{1-b}\) although we reveal the \(l\) bits.

The intuition behind the protocol security is as follows.
To achieve malicious-verifier zero-knowledge, choose \(k\) logarithmic in the security parameter \(\lambda\) and repeat the protocol \(n\) times, such that 
the knowledge error, \(2^{-kn}\), becomes small enough.
Repeating the protocol is also needed to decrease the success probability of some of adversaries presented below.

The \ac{DB} phase protects against distance fraud.
Once the prover has received \(l+1\) challenges set to \(b\), it knows that the remaining challenges must also be \(b\).
\Iac{DBDF} prover must thus wait for the challenge bit \(b_i\) before responding with \(r_i\) for \(l+1\) challenges.
Thus, the probability of successfully guessing the order of the challenge bits is \(2^{-(l+1)}\) per round or, in total, \(2^{-(l+1)n}\).

The \ac{DB} phase also ensures that \iac{DBMF} adversary will fail the \ac{DB} phase for at least one round.
The verifier will send \(|q| + l < 2|q|\) challenges.
By replying, the prover reveals \(|q|+l\) bits distributed over \(s_0, 
  s_1\).
\emph{We assume} that learning \(\ceil{(|q|+l)/2}\) bits of \(s_0\) and 
\(\floor{(|q|+l)/2}\) bits of \(s_1\) yields no advantage for the adversary.
Now, the adversary has two options.
First, the adversary can buffer \(l\) bits of both \(s_0^{(0)}\concat s_0^{(1)}, s_1^{(0)}\concat s_1^{(1)}\) by requesting them from the prover.
However, at this point the adversary must wait for the challenge bit \(b_{l+1}\) from the verifier and then relay that challenge to the prover to receive the correct \(r_i\) --- this relay will be detected.
The alternative is to guess \(b\) and extract \(s_b\) for this challenge from the prover.
Guessing \(b\) yields \(1/2\) probability that the \ac{DBMF} adversary will guess it correctly.
Since we must execute the protocol \(n\) times, the probability to pass all these rounds is reduced to \(2^{-n}\).
If the adversary requests \(s_b\) in full, the adversary can also guess the 
remaining \(|q|-l\) bits of \(s_{1-b}\).
Based on our assumption above, the probability of guessing these bits 
successfully is \(2^{-(|q|-l)}\).
Thus the success probability of the \ac{DBMF} adversary is \emph{at most} 
\(2^{-n}+2^{-(|q|-l)n}\).

The protocol is \ac{DBTF}-resistant. 
Indeed, if the malicious prover gives both responses to the accomplice, the accomplice can compute his secret key.
The probability of success of \ac{DBTF} is thus reduced to guessing \(b\), \ie \(1/2\) per round or, in total, \(2^{-n}\).

The protocol is also secure against distance hijacking due to the fact that the authenticated bitstring is used during the \ac{DB} phase, not the challenge bitstring as it is the case for the original protocol of Brands-Chaum.
Thus the probability of success is equivalent of a collision for the responses 
for the chosen challenge --- in each round.

Finally, it follows from the original Schnorr protocol that this is still \iac{PK} and \ac{ZK}.
\daniel{I should prove this for the composed protocol, I should check the details with Douglas.}

\subsection{Formal Verification}

We wanted to formally verify the protocol security properties. To realize this, 
we used the Tamarin prover~\cite{meier2013tamarin}. Tamarin does not include 
originally the possibility to reason on time and space in its model.
However, thanks to a recent work by \textcite{TamarinDB}, all the common 
properties mentioned in the previous subsection can be equivalently 
characterized with a causality-based definition relying only on the order of 
messages.

The whole Tamarin code we wrote is provided in \cref{apdx:tamarin-spec}, with a short discussion of the modeling choices that we have made. 
It contains a specification of the distance-bounding protocol described previously, a definition of the soundness and correctness properties that ensure the protocol actually produces the expected result, and a definition of the security properties we want to ensure.

Tamarin's auto-prover validated the soundness and correctness properties (in negligible computation time) but does not terminate when trying to prove the security properties.
This means that no trace violating the security properties is found, but the prover cannot conclusively validate that the desired properties are true. 
We are currently investigating the Tamarin interactive mode to validate as well the security properties.


