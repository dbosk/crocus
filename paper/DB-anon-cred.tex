\subsection{Distance-bounding anonymous credentials}%
\label{DB-anon-cred}

\ProvideDocumentCommand{\PPK}{o o}{\ensuremath{%
    \operatorname{PPK}%
    \IfValueT{#1}{%
      \IfValueTF{#2}{%
        \mleft\{\mleft(#1\mright) : #2\mright\}%
      }{%
        \mleft\{#1\mright\}%
      }%
    }%
  }}

One protocol exists in the literature that provides \acp{PPK} with all the 
desired properties described previously, ProProx~\cite{ProProx}\footnote{Note 
  that~\cite{ProProx} uses the abbreviation PoPoK, we prefer \acs{PPK} for 
  shorter notation.}.
However, ProProx provides \iac{PPK} protocol for quadratic residues (\ie protocols of the form \(\PPK[\alpha][a = \alpha^2]\)) while in our context, we need \iac{PPK} protocol for discrete logarithms (\ie \(\PPK[\alpha][a = g^\alpha]\)).
To realize this, we will now introduce such a protocol in order to enable us to have \ac{DB} anonymous credentials.

\NewScheme{\DBS}{DBS}
\NewAlgorithm{\DBSprove}{\DBS.\!Prove}
\NewAlgorithm{\DBSverify}{\DBS.\!Verify}

\emph{Reattempting a distance-bounding Schnorr protocol.}
In the original \ac{DB} paper by \citet{DistanceBounding}, one of the distance-bounding protocol is based on the Schnorr identification scheme~\cite{Schnorr}.
However, this \ac{DB} Schnorr protocol was shown to be prone to distance hijacking~\cite{DistanceHijacking}, in addition of also not being secure against terrorist fraud either.
We now propose another way to turn the Schnorr protocol into a public-key \iac{DB} protocol which is secure against \ac{DBMF}, \ac{DBDF}, \ac{DBDH}, \ac{DBTF} and an impersonating verifier.

We present the protocol in \cref{SchnorrFigure}.
The main difference with the original Schnorr protocol is that the prover commits to one random value but the verifier sends two challenges.
The verifier presents to the prover which commitments and challenges to use during the \ac{DB} phase.

\begin{figure*}
  \centering
  \begin{tabular}{p{5cm}cp{5cm}}
    \(\DBSprove[g, q, \alpha, A = g^\alpha]\):
    & &
    \(\DBSverify[g, q, A]\):
    \\
    \midrule

    \multicolumn{3}{c}{\textbf{Setup}} \\

    \(\rho\rgets \ZZ_q, R\gets g^{\rho}\)
    & \(\ProtoSendRight{R}\)
    &
    \\

    % null
    & \(\ProtoSendLeft{c_0, c_1}\)
    & \(c_0\rgets \bin^k, c_1\rgets \bin^k\)
    \\

    \(s_0\gets \rho + c_0\alpha \pmod q\)
    &
    & \(b\rgets \bin\)
    \\

    \(s_1\gets \rho + c_1\alpha \pmod q\)
    &
    & Prepare \(B\in \bin^{\ceil{\log_2 q}+l}\), with \(\ceil{\log_2 q}\) bits 
    set to \(b\).
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Distance-bounding}: \(\forall i: 0\leq i < 
        \ceil{\log_2 q} + l\)} \\

%    % null
%    &
%    & Random delay
%    \\

    % null
    & \(\ProtoSendLeft{b_i}\)
    & \(b_i\gets B[i]\)
    \\

    \(r_i\gets s_{b_i}[i]\)
    & \(\ProtoSendRight{r_i}\)
    & Record \(\Delta t_i\)
    \\

    \midrule
    \multicolumn{3}{c}{\textbf{Verification}}
    \\

    % null
    &
    & Construct \(r = s_b\) as the concatenation of \(r_i\)'s for which \(b_i = 
      b\).
    \\

    % null
    &
    & \(R \stackrel{?}{=} g^r A^{c_b}\)
    \\
    
  \end{tabular}
  \caption{%
    One-round protocol instance of the \(\DBSprove\leftrightarrow \DBSverify\) \ac{DB} Schnorr protocol for \(\PK[\alpha][A = g^\alpha]\).
    The protocol should be repeated in full to achieve the desired knowledge and distance-bounding errors.
  }%
  \label{SchnorrFigure}
\end{figure*}

The intuition behind the protocol security is as follows.
To achieve malicious-verifier zero-knowledge, choose \(k\) logarithmically with respect to the security parameter \(\lambda\) and repeat the protocol until the knowledge error is small enough.
This will actually also decrease the success probability of \iac{DBMF} adversary in the \ac{DB} step.
Indeed, the \ac{DBMF} adversary does not know which challenge the verifier will use, thus there is a \(1/2\) probability that the \ac{DBMF} adversary will guess it correctly.
The prover will only provide one of the responses: even if the adversary re-runs the protocol with the same challenges, the randomly chosen \(\rho_0, \rho_1\) will have changed --- which thus yields another \(R_b\) in the end of the protocol.
A sequential repetition of protocol will decrease this probability.

The \ac{DB} phase protects against distance fraud.
\Iac{DBDF} prover must wait for the challenge bit \(b_i\) before responding with \(r_i\).
The \ac{DB} phase also ensures that \iac{DBMF} adversary will fail the \ac{DB} phase for at least one round.
The verifier will send \(\ceil{\log_2 q} + l < 2\ceil{\log_2 q}\) challenges.
Afterwards, the prover reveals all the bits of either \(s_0\) or \(s_1\) but only \(l\) bits of the other.
Thus, the adversary can buffer \(l\) bits of both \(s_0, s_1\) by requesting them from the prover.
However, at this point the adversary must wait for \(b_{l+1}\) challenge bits from the verifier and then relay that challenge to the prover to receive the correct \(r_i\) --- this relay will be detected.

The protocol is \ac{DBTF}-resistant, indeed if the malicious prover gives both responses to the adversary, the adversary can compute his secret key.
This follows from the fact that it is \iac{ZKPK}, which means there is an extractor that can extract the secret.
The protocol is also secure against distance hijacking due to the fact that it is the authenticated bitstring that is used during the \ac{DB} phase, not the challenge bit string as in the protocol of Brands-Chaum.
