\section{Discussion}%
\label{Discussion}

The UWBPR protocol by \textcite{UWBPR} provides a device which sends and 
receives many bits \enquote{simultaneously}.
The many-bits version of our protocol (\cref{DB-Schnorr-UWB}) uses such 
devices.
The prover has one, the verifier has one.
Whatever the prover communicate to its the device, the verifier's device will 
give to the verifier.
This is what our assumption about sending many bits simultaneously captures.

To implement such devices, however, require shared-key cryptography.
The trivial solution is that every device has a secret key~\(k\), same as every 
other device.
Then every device can communicate with every other device and they would be 
mutually trusted too.

One could argue that with these trusted devices, would properties like 
\ac{DBDF} and \ac{DBDH} still make sense?
They do.
In the model of the first version of the protocol, the device just sends and 
receives.
The prover could instruct the device to send a string of bits before receiving 
something from the verifier.
All the device promises is to take and deliver all bits of a message at once 
--- not bit-by-bit.

In the trivial case above, where all devices share \(k\), everyone can listen 
in on the communication.
This makes \ac{DBDH} also a potential issue.

All devices sharing the same key is a key-management issue, that key \(k\) has 
a large attack surface.
To solve this key-management issue, we introduce \iac{PKI} and \ac{AKE}.
Privacy is an increasingly important property is this type of system.
That is why we do the \ac{AKE} using CL04~\cite{CLsignatures} anonymous 
credentials (or privacy-preserving attribute-based credentials).
However, one can also construct group signatures using CL04~\cite{CLsignatures} 
and we can, thus, add revocation possibilities.
For instance, this is actually part of the \ac{DAA} protocol of the \ac{TPM} 
standard.

For completeness, we also provided a classical bit-by-bit version of the 
protocol (\cref{DB-Schnorr-nbit}).
The essential difference between the many-bits and bit-by-bit version is that 
in the many-bits version the user must essentially commit to the messages in 
advance by giving them all at the same time to the communication device.
The device sends and receives many bits \enquote{simultaneously}, there is no 
receiving some bits while sending others, to create a buffer.
This is what the assumptions in the many-bits version model and what is absent 
in the bit-by-bit version.
Hence the difference in \ac{DBTF} resistance.

This buffer that the adversary and prover can build to commit \ac{DBTF} is 
limited, though.
Essentially, for every bit in the buffer, the prover and adversary buy one 
factor \(t_{\max}/2\) in time (\ie distance).
So they can only commit \ac{DBTF} as long as the prover is not \enquote{too 
far} from the verifier.
The farther the prover is, the more bits of the second response he must leak.
If he leaks too much, the adversary will be able to efficiently compute the 
secret key.
So they can only commit \ac{DBTF} while the prover is within some distance from 
the verifier.
However, we leave the formal analysis of this as future work.
