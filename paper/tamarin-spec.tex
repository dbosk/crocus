\subsection{Specification of the distance-bounding protocol used by \PRIVO in Tamarin}
\label{apdx:tamarin-spec}

\begin{lstlisting}

/* Implementation of the DB protocol */
/* Demonstrating the DB-secure property */

theory crocusclean

begin

functions: adec/2, aenc/2, pk/1

equations: adec(aenc(message, secretkey), 
           pk(secretkey)) = message

builtins: signing

// -------- Tag Initialization --------- //

rule Register_Keypair:
[ Fr(~key) ]
--[ Once($A), Prelim()]->
[ !Pk($A, pk(~key)), !Ltk($A, ~key), 
  Out( pk(~key) ), !Agent($A)
  ]

rule Corrupt_Agent:
[ !Ltk($A, ltk) ]
--[ Corrupt($A), Prelim() ]->
[ Out(ltk), !CorruptAgent($A) ]

rule Corrupt_Fast:
[ !CorruptAgent($A), In(msg) ]
--[ CAction($A), Action($A) ]->
[ FastMsg(msg) ]


// ------- Protocol Rules ---- //

//1. Prover chose r, compute and send R
//2. Verifier chooses two nonces c_0 and c_1,
//   and sends them to Prover
//3. Verifier chooses b = 0 or 1, 
//   sends to Prover
//4. Prover receives + encodes both c_i 
//   with x and sign them with r
//5. Prover receives b,
//   sends back corresponding c
//6. Verifier verifies the signature 
//   and decodes the messsage, 
//   checks it's the correct c


// 1. Prover chose r, compute and send R

rule Prover_1:
[ !Agent($Prover) 
, Fr(~r)
]
--[ ProverStart($Prover)
, Action($Prover)
]->
[ ProverSess($Prover, ~r) 
, Out( pk(~r) )
]


//2. Verifier chooses two nonces c_0 and c_1 
//   and sends them to Prover

rule Verifier_1:
[ In( R ) 
, Fr(~challenge0) , Fr(~challenge1)
]
--[ VerifierCommit( ~challenge0, ~challenge1 ) 
, PreFastPhase( <~challenge0, ~challenge1> )
]->
[ VerifierSess(R, ~challenge0, ~challenge1) 
, Out( <~challenge0, ~challenge1> )
]


//3. Verifier chooses b = c0 or c1, 
//   and sends it to Prover

rule Verifier_2:
[ VerifierSess(R, c0, c1) 
, Fr(~b) 
]
--[ Choose(c0, c1, ~b)
, VerifierSelect(~b) 
, StartFastPhase(c0, c1) 
]->
[ VerifierStartFast(R, c0, c1, ~b)
, FastMsg( ~b ), Out( ~b ) 
]


//4. Prover receives and stores both c_i 

rule Prover_2:
[ ProverSess($Prover, r) 
, In( <c0, c1> ) 
]
--[ ProverStore(c0, c1) 
, ReadyFastPhase( c0, c1 ) 
, Action($Prover)
]->
[ ProverStartFast( $Prover, r, c0, c1 ) 
]


//5. Prover receives b and sends it back
//   encoded with x and signed with r

rule Prover_3:
let response = aenc{b, sign(b,x)}r
in
[ ProverStartFast( $Prover, r, c0, c1 ) 
, FastMsg( b ) 
, !Ltk( $Prover, x ) 
]
--[ Choose(c0,c1,b) 
, ProverReply($Prover, c0, c1, b)
, ReplyFastPhase(c0, c1, b)
, Action($Prover)
]->
[ FastMsg( response ), Out( response ) 
]

//6. Verifier verifies the signature and 
//   decodes the messsage,
//   checks it's the correct c

rule Verifier_3:
let clear_text = adec( response, R )
authentication = verify( 
                   snd(clear_text),
                   fst(clear_text),
                   X
                 )
proof = fst(clear_text)
in
[ VerifierStartFast(R, c0, c1, b) 
, FastMsg( response )
, !Pk( $Prover, X )
]
--[ Eq(authentication, true), Eq(proof, b)
, VerifierComplete($Prover, R, c0, c1, b) 
, EndFastPhase(c0,c1,b)  
]->
[]


// ----- Axioms ------- //

restriction at_most_once:
"
All A #t1 #t2. Once(A)@t1 & Once(A)@t2 ==>
(
#t1 = #t2
)
"

restriction equals:
"
All a b #t1. Eq(a,b)@t1 ==>
(
a = b
)
"
// ----- Sanity Check Lemmas ----- //

lemma verif1_exists:
exists-trace
"
Ex c0 c1 #t. (
VerifierCommit( c0, c1 )@t )
"

lemma prover2_exists:
exists-trace
"
Ex Prover c0 c1 b #t. (
ProverReply( Prover, c0, c1, b )  @t )
"

lemma startfast_exists:
exists-trace
"
Ex c0 c1   #t. (
StartFastPhase(c0, c1)@t
) &
not(Ex A #tc. Corrupt(A)@tc)
"


lemma endfast_exists:
exists-trace
"
Ex c0 c1 b  #t. (
EndFastPhase(c0, c1, b)@t
) &
not(Ex A #tc. Corrupt(A)@tc)
"

lemma end_exists:
exists-trace
"
Ex P R c0 c1 b  #t. (
VerifierComplete(P, R, c0, c1, b)@t
) &
not(Ex A #tc. Corrupt(A)@tc)
"


// ----- Security Lemmas ----- //

lemma dbsec:
// Whenever the verifier is complete EITHER:
//  1) There exists t1, t2 and t3 such that
//          The fast phase was between t1 and t3
//          and prover did smthg btwn t1 and t3
//          and verifier completed at/after the
//          end of the fast phase
//OR
//  2) There exist times t5, t6 and t7 such that
//        The fast phase was between t5 and t7
//        and the prover P is dishonest
//        and some dishonest agent did smthg 
//        during the fast phase
//        and the verifier completed at/after the
//        end of the fast phase 
"
All P R c0 c1 b  #t. (
VerifierComplete(P, R, c0, c1, b)@t ) ==>                   
(                                                         
Ex #t1 #t2 #t3. StartFastPhase( c0, c1 )@t1 &              
Action(P)@t2 &                              
EndFastPhase( c0, c1, b )@t3 &            
(#t1 < #t2) &                               
(#t2 < #t3) &                               
( (#t3 < #t ) | (#t3 = #t) )
)|
(              
Ex CAgent #t4 #t5 #t6 #t7.
StartFastPhase( c0, c1 )@t5 &    
EndFastPhase( c0, c1, b )@t7 & 
Corrupt(P)@t4 &             
CAction(CAgent)@t6 &             
(#t5 < #t6)&                     
(#t6 < #t7)&                     
( (#t7 < #t) | (#t7 = #t) )      
) 
"

end
\end{lstlisting}

