\section{\PRIVO:\@ A protocol for crowd counting estimation}%
\label{Protocol}


We now present \PRIVO, a protocol for securely and privately verifying crowd counts.
The protocol consists of five phases: setup, join, participation, submission and verification phases.
The setup is described in \cref{ProtocolSetup}.
The join, participation and submission phases are detailed in \cref{ProtocolDuring}.
Finally, the verification phase is presented in \cref{ProtocolVerification}.

Several entities are involved in our protocol.
First, \iac{CA} is responsible for certifying a one-to-one mapping between a 
person's identity and a cryptographic key\footnote{%
  This can be done by a centralized authority, such as a nation state with, 
  \eg, passports; or a decentralized authority, as in the case of 
  proof-of-personhood~\cite{proof-of-personhood}.
}.
The \ac{CA} is only involved in the setup phase.
Second, a protester is an individual who wants to participate in a given protest.
A protester can assume three different roles:
\begin{enumerate}
\item The \emph{organizer} has written a manifesto for the protest and forward it to others.
\item A \emph{participant} is attending the protest and asks witnesses to vouch for his presence.
\item A \emph{witness} provides proofs to participants that state the participant was indeed participating and such that the proofs are verifiable by third parties.
\end{enumerate}
In general, there is one organizer and every protester will act alternatively as both participant and witness.

\subsection{Setup phase}%
\label{ProtocolSetup}

The setup phase is only run once and is the same as in Anon-Pass~\cite{AnonPass}.
More precisely, we have simply adapted their description to our notation, but otherwise we have the setting as similar as possible.


\emph{Setup: \((\spk, \ssk)\gets \PRIVOsetup\).}
During the setup phase, the \ac{CA} creates all the needed keys.
First, the \ac{CA} generates a service public-private key-pair \((\spk, \ssk)\) as follows.
Let \(G = \gen g\) be a group with generator \(g\) and prime order \(q\).
Let \(G_T\) be a group such that there is a bilinear pairing \(e\colon G\times G\to G_T\)\footnote{%
  \Ie \(e(g_1^a, g_2^b) = e(g_1, g_2)^{ab}\) and if \(G = \gen{g_1} = 
    \gen{g_2}\) then \(G_T = \gen{e(g_1, g_2)}\).
}.
Choose \(x,y,z\rgets \ZZ_q\) uniformly at random and set \(X = g^x, Y = g^y, Z = g^z\).
The service public key is set to \(\spk = (q, G, G_T, g, X, Y, Z)\) and the service private key to \(\ssk = (x, y, z)\).


\emph{Registration: \(\sk\gets 
    \Proto{\PRIVOreg[_P][\spk]}{\PRIVOreg[_{CA}][\ssk]}\).}
During the registration phase, each protester generates a secret key and obtains a signature on it by the \ac{CA} but without revealing it to the \ac{CA}.
At the end, each protester will have a signed secret key while the \ac{CA} will issue only one signature per protester but without knowing the association between a particular key and the identity of the user.
The protester chooses \(k, r\rgets \ZZ_q\) uniformly randomly, sets \(M = g^k Z^r\) and sends \(M\) to the server.
The protester acts as prover and the \ac{CA} as verifier while they perform the following \ac{ZKPK} protocol:
\[
  \PK[k,r][M = g^k Z^r].
\]
If the proof succeeds, the \ac{CA} chooses \(a\rgets \ZZ_q^*\) and sets \(A = g^a\).
Afterwards, he forms the signature \(\sigma = (A, B = A^y, Z_B = B^z = Z^{ay}, C = A^x M^{axy})\) and sends it to the protester.
The protester then verifies that the following equations hold:
\begin{align*}
  A &\neq 1 \\
  e(g, B) &= e(Y, A) \\
  e(g, Z_B) &= e(Z, B) \\
  e(g, C) &= e(X, A) e(X, B)^k e(X, Z_B)^r.
\end{align*}
Upon success, the protester sets \(\sk = (\sigma, k, r)\).

The setup and registration phases can be done once and the keys can be reused for an arbitrary number of protests.
Thus, the registration phase could be easily integrated as part of the issuance of national identity cards, passports or \acp{eID}.

\subsection{Creation, join and participation in a protest and submission of proofs}%
\label{ProtocolDuring}

The join, participation and submission phases are illustrated in \cref{fig:ProtocolOverview}.
The participation proof share that will be constructed in the participation phase is illustrated in \cref{fig:ProofFig}.

\emph{Creation of a protest: the manifesto.}
The organizer will write a manifesto for the protest, which describes its cause.
This manifesto could take the form of any intelligible text.
The organizer will then distribute this manifesto to people through any means he wants (\eg on the Web, on placards, \etc).
If they agree on the cause, they will use the knowledge of the manifesto to join the protest.


\emph{Joining as a participant: \((\pid, t_s)\gets 
    \PRIVOjoin[_P][\text{manifesto}]\).}
A participant who wants to join the protest will use the manifesto to compute an identifier for the cause by hashing the manifesto, \(\cid\gets \Hash[\mfst]\).
Afterwards, this identifier is used to create the protest-specific identifier for the participant, \(\pid\gets \ACprf[_{\sk}][\cid]\) (in 
\cref{fig:ProofFig,fig:ProtocolOverview}).
More specifically, \(\pid = g_T^{1/(k+\cid)}\) (remember that \(\sk = (\sigma, k, r)\)).
The participant should also receive a time-correlated random value from the time-stamping service, \(t_s\gets \TSget\).


\begin{figure}
  \centering
  %\footnotesize
  \includegraphics{proofshare.tikz}
  \caption{%
    Structure of a proof share.
    The protest (cause) identifier \(\cid\) is the hash value of the manifesto.
    The protester \(P\)'s identifier \(\pid\) is computed using the protester's key \(\sk_P\) and \(\cid\).
    The witness \(W\)'s identifier \(\wid\) is computed using the
    witness's key \(\sk_W\) and \sonja{the other's?}\(\pid\).
    \(t_s, t_s'\) are the last heads of the blockchain seen by the protester and witness, respectively, and \(l\) is an area.
    All values are signed by the witness while also proving the correctness of \(\wid\) and knowledge of a signature on \(\sk_W\).
  }%
  \label{fig:ProofFig}
\end{figure}%

\begin{figure}
  \centering
  %\footnotesize
  \begin{minipage}{\linewidth}
    \begin{align*}
      O\to \text{all}\colon & \text{manifesto} \\
      P\colon & t_s\gets \TSget \\
        & \cid\gets \Hash[\text{manifesto}], \\
        & \pid\gets \ACprf[_{\sk_P}][\cid] \\
      W\colon & t_s'\gets \TSget
      \\[-1em]
      \noalign{\hfill Join}
      \midrule
      \noalign{\hfill Participation}
      \\[-3em]
      P\to W\colon & \pid \\
      P\leftrightarrow W\colon &
        \PPK\mleft\{ (\sk_P) : \mright. \\
        & \qquad \pid = \ACprf[_{\sk_P}][\cid], \\
        & \qquad \mleft. \sigma_P' = \ACblind[\ACsign[_{\ssk}][\sk_P]] \mright\} 
        \\
      W\colon & \wid\gets \ACprf[_{\sk_W}][\pid] \\
      W\to P\colon & (\wid, t_s', l)
      \\[-1em]
      \noalign{\hfill Participation}
      \midrule
      \noalign{\hfill Submission}
      \\[-2em]
      P\colon & t_e\gets \TSstamp[\Hash[\pid, \wid, t_s, t_s', l]] \\
      W\colon & t_e'\gets \TSstamp[\Hash[\pid, \wid, t_s, t_s', l]] \\
      W\to S\colon & (\pid, \wid, t_s, t_s', t_e, l, \pi_{\wid}),\quad 
      \text{where} \\
        & \pi_{\wid} = \SPK\mleft\{ (\sk_W) : \mright. \\
        & \qquad \wid = \ACprf[_{\sk_W}][\pid], \\
        & \qquad \mleft. \sigma_W' = \ACblind[\ACsign[_{\ssk}][\sk_W]]\mright\} 
        \\
        & \qquad\qquad (\pid, \wid, t_s, t_s', l) \\
      P\to S\colon & (\cid, \pid, \wid, t_s, t_s', t_e, l, \pi_{\pid}),\quad 
      \text{where}\\
        & \pi_{\pid} = \SPK\mleft\{ (\sk_P) : \mright. \\
        & \qquad \pid = \ACprf[_{\sk_P}][\cid], \\
        & \qquad \mleft. \sigma_P' = \ACblind[\ACsign[_{\ssk}][\sk_P]] \mright\} 
        \\
        & \qquad\qquad (\cid, \pid, \wid, t_s, t_s', l)
    \end{align*}
  \end{minipage}
  \caption{%
    An overview of the Join, Participation and Submission phases of \PRIVO.\@
    The organizer \(O\) broadcasts the manifesto.
    The protester \(P\), witness \(W\) and their computations are as in \cref{fig:ProofFig}.
    Finally, both \(P\) and \(W\) submits the proof shares to a permanent storage \(S\).
  }%
  \label{fig:ProtocolOverview}
\end{figure}

\emph{Joining as a witness: \(t_s'\gets \PRIVOjoin_W\).}
The witness should simply get a time-correlated random value from the time-stamping service, \(t_s'\gets \TSget\).
Note that we do this for redundancy, the newest of \(t_s\) and \(t_s'\) will be set the start of the time interval of creation for the proof share.


\emph{Participation: \(\pi\gets
    \Proto{\PRIVOparticipate[\cid, \sk_P]}{\PRIVOwitness[\sk_W, \spk]}\),}
In the participation phase, the participant and the witness construct the proof share of the participant (\cref{fig:ProofFig}).
The participant blinds his signature \(\sigma\) on his secret key by choosing \(r_1, r_2\rgets \ZZ_q^*\) and generates \(
  \tilde\sigma = (\tilde A = A^{r_1},
                  \tilde B = B^{r_1},
                  \tilde Z_B = Z_B^{r_1},
                  \hat C = C^{r_1 r_2}).
\) 
Note that it is not necessary to compute a new \(\tilde\sigma\) more than once per \(\pid\).
The participant sends \((\pid, \tilde\sigma)\) to the witness.
The witness verifies that
\begin{align*}
  \tilde A          &\neq 1 \\
  e(g, \tilde B)    &= e(Y, \tilde A) \\
  e(g, \tilde Z_B)  &= e(Z, \tilde B).
\end{align*}
Both the participant and the witness compute
\begin{align*}
  v &= e(g, \hat C) \\
  v_x &= e(X, \tilde A) \\
  v_{xy} &= e(X, \tilde B) \\
  v_{xy}' &= e(X, \tilde Z_B).
\end{align*}
Afterwards, they run the following \ac{PPK} with the participant as the prover and the witness as the verifier:
\begin{multline*}
  \mleftright
  \PPK\left\{(k, r, r') : v^{r'} = v_x v_{xy}^k v_{xy}^{\prime r} \land
    \pid = g_T^{1/(k+\cid)} \right\}.
\end{multline*}
in which \(r' = 1/r_2\).
We can rewrite \(\pid = g_T^{1/(k+\cid)}\) as \(\pid^k = g_T g_T^{-\cid}\).
Afterwards, the \ac{PK} can be designed as follows\footnote{Remember that this \ac{PK} should be run as \iac{PPK} and repeated multiple times to achieve security.}.
The participant chooses \(r_k, r_r, r_{r'}\rgets \ZZ_q\) uniformly at random, sets \(R_1 = v^{r_{r'}} v_{xy}^{r_k} v_{xy}^{\prime r_r}\) and \(R_2 = \pid^{r_k}\) and sends \(R_1, R_2\) to the witness.
The witness replies with a challenge \(c\).
Afterwards, the participant computes
\begin{align*}
s_k &= -ck + r_k, \\
s_r &= -cr + r_r, \\
s_{r'} &= cr' + r_{r'}
\end{align*}
and forwards them to the witness.
The witness checks whether
\begin{align*}
  v_x^c R_1 &\overset{\mathclap{?}}{=} v^{s_{r'}} v_{xy}^{s_k} v_{xy}^{\prime 
    s_r}, \\
  \mleft(g_T \pid^{-\cid}\mright)^{-c} R_2 &\overset{\mathclap{?}}{=} 
  \pid^{s_k}.
\end{align*}
If the proof succeeds, the witness computes \(\wid\gets \ACprf[_{\sk_W}][\pid] = g_T^{1/(k_W+\pid)}\) (as above).
Following this, the witness returns \((\wid, t_s', l)\) to the participant.
As a consequence, both the participant and the witness have the tuple \(\pi = (\pid, \wid, t_s, t_s', l)\), which forms a proof share of the participant (\cref{fig:ProofFig}).


\emph{Submission: \(\psh_P\gets \PRIVOsubmit[_P][\cid, \pid, \wid, t_s, t_s',  l]\).}
The participant should as soon as possible commit the proof-share data to the time-stamping service and receive the proof of commitment, \(t_e\gets 
  \TSstamp[\Hash[\pid, \wid, t_s, t_s', l]]\).
The remaining operations are not time critical.
The participant computes \iac{NIZK} proof \(\pi_{\pid}\), which shows the correctness of \(\pid\).
More specifically,
\begin{multline*}
  \pi_{\pid}\gets \SPK\left\{ (\sk_P) : \right. \\
    \begin{aligned}
      \pid &= \ACprf[_{\sk_P}][\cid] \quad \land \\
      \sigma_P' &= \left. \ACblind[\ACsign[_{\ssk}][\sk_P]] \right\}
    \end{aligned} \\
      (\cid, \pid, \wid, t_s, t_s', l).
\end{multline*}
Finally, the participant uploads the tuple \[  \psh_P = (\cid, \pid, \wid, t_s, t_s', t_e, l, \pi_{\pid})\] for permanent storage.

\emph{Submission: \(\psh_W\gets \PRIVOsubmit[_W][\pid, \wid, t_s, t_s', l]\).}
The witness should, just as the participant, commit the proof-share data to the time-stamping service, \(t_e'\gets \TSstamp[\Hash[\pid, \wid, t_s, t_s', l]]\).
(This is only for redundancy.)
Then, without any time requirements, the witness computes \iac{NIZK} proof 
\(\pi_{\wid}\) as follows:
\begin{multline*}
  \pi_{\wid}\gets \SPK\left\{ (\sk_W) : \right. \\
    \begin{aligned}
      \wid &= \ACprf[_{\sk_W}][\pid] \quad \land \\
      \sigma_W' &= \left. \ACblind[\ACsign[_{\ssk}][\sk_W]] \right\}
    \end{aligned} \\
      (\pid, \wid, t_s, t_s', l).
\end{multline*}
Finally, the witness uploads the tuple \[ \psh_W = (\pid, \wid, t_s, t_s', t_e', l, \pi_{\wid}) \] for permanent storage.

\subsection{Verifying the participation count}%
\label{ProtocolVerification}

While there are various ways for verifying the participation count, hereafter we will detail the two suggested just after \cref{DefParticipationCount}.
In the first approach, we do not trust individual witnesses, rather we \emph{assume} that it is difficult for Alice to find more than \(\theta\) witnesses willing to collude.
Thus, the strength comes from the number of witnesses and we require at least \(\theta\) witnesses to accept a participation proof as valid.
In the second approach, we have a higher trust in specific witnesses and no 
trust in others.
In this case, to accept a participation proof as valid, we require at least one trusted witness, the independent journalist Jane.

To verify the participation count for a protest \(P = (\cid, t, l)\) (see 
\cref{DefProtest}), a verifier must download all the proof shares \(\psh_i =   
  (\cid, \pid_i, \wid_i, t_s^{(i)}, t_s^{\prime (i)}, t_e^{(i)}, t_e^{\prime   
    (i)}, l_i, \prf_{\pid_i}, \prf_{\wid_i})\), from the blockchain and verify 
\(\prf_{\pid_i}\) and \(\prf_{\wid_i}\) and that the interval starting at the 
latest of \(t_s^{(i)}, t_s^{\prime (i)}\) and ending at the earliest of 
\(t_e^{(i)}, t_e^{\prime (i)}\) is a subset of \(t\) and that \(l_i\subseteq  
  l\).
Any proof share that does not verify correctly will be discarded.
At this point, the verifier has constructed the set \(S\) from 
\cref{DefProofShares} and can thus construct any participation proof 
\(\prf_{\pid_i, P}\) as in \cref{DefParticipationProof}.
Now the verifier can compute the participation count \(|\prfs_P^{\str, 
    \theta}|\) as in \cref{DefParticipationCount}.
It is the strength function \(\str\) that differ in the two cases we give.

In the case \emph{without} trusted witnesses, the verifier simply define 
\(\str[\prf_{\pid_i, P}] = |\prf_{\pid_i, P}|\) and set \(\theta\) to our 
desired thresold.

In the case \emph{with} trusted witnesses, each trusted witness must inform the 
verifier of which proof shares that he or she has signed, \eg by giving a list 
of all such proof shares or digitally sign each proof share.
Then the verifier defines \[
  \str[\prf_{\pid_i, P}] = \begin{cases}
    1 & \text{if \(\prf_{\pid_i, P}\) is such a proof share} \\
    0 & \text{otherwise}
  \end{cases}
\] and sets \(\theta = 1\).
