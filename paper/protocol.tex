\section{\PRIVO:\@ A protocol for protest outcome verification}%
\label{protocol}

\NewCryptoScheme{\PRIVOscheme}{PRIVO}

We now present \PRIVO, a protocol for securely and PRIvately Verifying PROtests.
The protocol consists of four phases: the setup, join, participation and 
submission phases.
We have several roles.
We have \iac{CA} who is responsible for a one-to-one mapping between a person's 
identity and a cryptographic key.
We have the protesters who want to participate in a given protest.
A protester can assume three different roles:
\begin{enumerate*}
\item We have the \emph{organizer} who will simply write a manifesto for the 
  protest and spread to others.
\item A \emph{participant} participates in the protest (and asks witnesses to 
  vouch for his presence).
\item A \emph{witness} provides proofs to participants that state the 
  participant was indeed participating and the proofs are verifiable by third 
  parties.
\end{enumerate*}
In general, there is one organizer and every protester will act as both 
participant and witness.

The setup and registration phases are the same as in Anon-Pass~\cite{AnonPass}.
We have simply adapted their description for our notation, but tried to keep 
them as similar as possible.

\NewAlgorithm{\PRIVOsetup}{Setup}

\emph{Setup: \((spk, ssk)\gets \PRIVOsetup\).}
The setup phase is for the \ac{CA} to set up all the needed keys.
The \ac{CA} generates a service public-private key-pair \((spk, ssk)\) as 
follows.
Let \(G = \gen g\) be a group with generator \(g\) and prime order \(q\).
Let \(G_T\) be a group such that there is a bilinear pairing \(e\colon G\times 
  G\to G_T\)\footnote{%
  \Ie \(e(g_1^a, g_2^b) = e(g_1, g_2)^{ab}\) and if \(G = \gen{g_1} = 
    \gen{g_2}\) then \(G_T = \gen{e(g_1, g_2)}\).
}.
Choose \(x,y,z\rgets \ZZ_q\) uniformly at random and set \(X = g^x, Y = g^y, Z = 
  g^z\).
Then the service public key \(spk = (q, G, G_T, g, X, Y, Z)\) and the service 
private key \(ssk = (x, y, z)\).

\NewAlgorithm{\PRIVOreg}{Register}

\emph{Registration: \(sk\gets 
    \Proto{\PRIVOreg[_P][spk]}{\PRIVOreg[_{CA}][ssk]}\).}
During the registration phase, each protester will generate a secret key and 
obtain a signature on it by the \ac{CA} --- without revealing it to the \ac{CA}.
Thus each protester will have a signed secret key, the \ac{CA} will issue only 
one signature per protester but will not know who has which key.
The protester chooses \(k, r\gets \ZZ_q\) uniformly randomly and sets \(M = g^k 
  Z^r\) and send \(M\) to the server.
The protester acts as prover and the \ac{CA} as verifier while they perform the 
following \ac{ZKPK} protocol:
\[
  \PK[k,r][M = g^k Z^r].
\]
If the proof succeeds, the \ac{CA} chooses \(a\gets \ZZ_q^*\) and sets \(A = 
  g^a\).
Then it forms the signature \(\sigma = (A, B = A^y, Z_B = B^z = Z^{ay}, C = A^x 
  M^{axy})\) and sends it to the protester.
The protester verifies that the following equations hold:
\begin{align*}
  A &\neq 1 \\
  e(g, B) &= e(Y, A) \\
  e(g, Z_B) &= e(Z, B) \\
  e(g, C) &= e(X, A) e(X, B)^k e(X, Z_B)^r.
\end{align*}
Upon success, the protester uses \(sk = (\sigma, k, r)\).

The setup and registration phases can be done once and the keys reused for an 
arbitrary number of protests.
Thus it would be suitable to have the registration phase as part of the issuance 
of \eg national identity cards, passports or \acp{eID}.

\emph{Creating a protest: the manifesto.}
The organizer will write a manifesto for the protest, \ie to capture the cause.
This manifesto is simply any intelligible text.
He will distribute this manifesto to people: on the Web, on placards, \etc.
If they agree, they will use it to join the protest.

\NewAlgorithm{\PRIVOjoin}{Join}

\emph{Joining participant: \((pid, t_s)\gets 
    \PRIVOjoin[_P][\text{manifesto}]\).}
A participant who wants to join the protest will use the manifesto to compute an 
identifier for the cause, \(cid\gets \Hash[\text{manifesto}]\).
Then this identifier is used to create the participant's protest-specific 
identifier, \(pid\gets \ACprf[_{sk}][cid]\) (in 
\cref{fig:ProofFig,fig:ProtocolOverview}).
More specifically, \(pid = g_T^{1/(k+cid)}\) (remember that \(sk = (\sigma, k, 
  r)\)).
The participant should also get a time-correlated random value from the 
time-stamping service, \(t_s\gets \TSget\).

\emph{Joining witness: \(t_s'\gets \PRIVOjoin_W\).}
The witness should simply get a time-correlated random value from the 
time-stamping service, \(t_s'\gets \TSget\).
(We do this for redundancy, the newest of \(t_s\) and \(t_s'\) will set the 
start of the time interval of creation for the proof share.).

\NewAlgorithm{\PRIVOparticipate}{Participate}
\NewAlgorithm{\PRIVOwitness}{Witness}

\emph{Participating: \(\pi\gets
    \Proto{\PRIVOparticipate[cid, sk_P]}{\PRIVOwitness[sk_W, spk]}\),}
The participant reblinds its signature \(\sigma\) on its secret key: choose 
\(r_1, r_2\gets \ZZ_q^*\) and let \(
  \tilde\sigma = (\tilde A = A^{r_1},
                  \tilde B = B^{r_1},
                  \tilde Z_B = Z_B^{r_1},
                  \hat C = C^{r_1 r_2}).
\) (It is not necessary to compute a new \(\tilde\sigma\) more than once per 
\(pid\).)
The participant sends \((pid, \tilde\sigma)\) to the witness.
The witness verifies that
\begin{align*}
  \tilde A          &\neq 1 \\
  e(g, \tilde B)    &= e(Y, \tilde A) \\
  e(g, \tilde Z_B)  &= e(Z, \tilde B).
\end{align*}
Both the participant and the witness compute
\begin{align*}
  v &= e(g, \hat C) \\
  v_x &= e(X, \tilde A) \\
  v_{xy} &= e(X, \tilde B) \\
  v_{xy}' &= e(X, \tilde Z_B).
\end{align*}
Then they run the following \ac{DBPK} with the participant as the prover and the 
witness as the verifier:
\begin{multline*}
  \DBPK\left\{(k, r, r') : v^{r'} = v_x v_{xy}^k v_{xy}^{\prime r} \land
    pid = g_T^{1/(k+cid)} \right\},
\end{multline*}
where \(r' = 1/r_2\).

\NewAlgorithm{\PRIVOsubmit}{Submit}


\subsection{Old}

We will start by giving an overview of the protocol.
We have a number of participants.
We have a cothority who provide the storage in a decentralized manner.
The cothority should consist of independent actors, preferably with conflicting 
interests so that they will not collude.
We have Alice the organizer and Bob the participant who are both protesters.
We have the trustworthy journalist Jane who is present but not participating in 
the protest.
The protesters will witness each others participation proofs, \eg Alice will 
witness Bob's proof and Bob will witness Alice's proof.
The result of witnessing a proof is a proof share (essentially a witness 
signature).
Jane will also participate in witnessing the protesters' proofs.
The witnessing is done through local interaction.
As soon as Alice and Bob have departed from the protest they upload their proofs 
(\ie all proof shares) to the cothority for indefinite storage.
Since each proof consists of one proof share for each witness, each witness 
could potentially upload the proof share themselves to the cothority.
This would have the same effect but with added redundancy, in case Alice or Bob 
cannot upload them themselves.

We will now describe the protocol in more details.
We will describe it in the same order as outlined above:
starting with the construction of the participation proof (shares) and 
submitting the proof shares to storage.
Then we will conclude with how to verify the proofs and produce the 
participation count.

\subsection{Constructing the participation-proof shares}

An overview of the final structure of a proof is given in \cref{fig:ProofFig} 
and an overview of the communication is given in \cref{fig:ProtocolOverview}.

\begin{figure}
  \centering
  \footnotesize
  \includegraphics{proofshare.tikz}
  \caption{%
    Structure of a proof share.
    The protester \(P\)'s identifier \(pid\) is computed using the protester's 
    key \(k_P\).
    The witness \(W\)'s identifier \(wid\) is computed using the witness's key 
    \(k_W\).
    \(t_s\) is a time interval and \(l\) is the coordinates of an area.
    The protest (cause) identifier \(cid\) is the hash value of the manifesto.
  }%
  \label{fig:ProofFig}
\end{figure}%

\begin{figure}
  \centering
  \footnotesize
  \begin{minipage}{\linewidth}
    \begin{align*}
      O\to \text{all}\colon & \text{manifesto} \\
      P\colon & t_s\gets \TSget \\
        & cid\gets \Hash[\text{manifesto}], \\
        & pid\gets \ACprf[_{sk_P}][cid] \\
      W\colon & t_s'\gets \TSget
      \\[-1em]
      \noalign{\hfill Join}
      \midrule
      \noalign{\hfill Participation}
      \\[-3em]
      P\to W\colon & pid \\
      P\leftrightarrow W\colon &
        \DBPK\mleft\{ (sk_P) : \mright. \\
        & \qquad pid = \ACprf[_{sk_P}][cid], \\
        & \qquad \mleft. \sigma_P' = \ACblind[\ACsign[_{ssk}][sk_P]] \mright\} 
        \\
      W\colon & wid\gets \ACprf[_{sk_W}][pid], \\
        & wsig\gets \ACprf[_{sk_W}][wid, t_s, t_s', l] \\
      W\to P\colon & (wid, t_s, t_s', l, wsig)
      \\[-1em]
      \noalign{\hfill Participation}
      \midrule
      \noalign{\hfill Submission}
      \\[-2em]
      P\colon & t_e\gets \TSstamp[\Hash[pid, wid, t_s, t_s', l, wsig]] \\
      W\colon & t_e'\gets \TSstamp[\Hash[pid, wid, t_s, t_s', l, wsig]] \\
      W\to S\colon & (pid, wid, t_s, t_s', t_e, l, wsig, \pi_W),\quad 
      \text{where} \\
        & \pi_W = \SPK\mleft\{ (sk_W) : \mright. \\
        & \qquad wid = \ACprf[_{sk_W}][pid], \\
        & \qquad wsig = \ACprf[_{sk_W}][wid, t_s, t_s', l], \\
        & \qquad \mleft. \sigma_W' = \ACblind[\ACsign[_{ssk}][sk_W]]\mright\} \\
        & \qquad\qquad (pid, wid, t_s, t_s', l, wsig) \\
      P\to S\colon & (pid, wid, t_s, t_s', t_e, l, wsig, \pi_P),\quad 
      \text{where}\\
        & \pi_P = \SPK\mleft\{ (sk_P) : \mright. \\
        & \qquad pid = \ACprf[_{sk_P}][cid], \\
        & \qquad \mleft. \sigma_P' = \ACblind[\ACsign[_{ssk}][sk_P]] \mright\} 
        \\
        & \qquad\qquad (pid, wid, t_s, t_s', l, wsig)
    \end{align*}
  \end{minipage}
  \caption{%
    An overview of of the Join, Participation and Submission phases of \PRIVO.\@
    The organizer \(O\) broadcasts the manifesto.
    The protester \(P\), witness \(W\) and their computations are as in 
    \cref{fig:ProofFig}.
    Finally, both \(P\) and \(W\) submits the proof share to the storage \(S\).
  }%
  \label{fig:ProtocolOverview}
\end{figure}

\subsubsection{Linkability and designated protest}

\Cref{CountOnce} is required to prevent Sybil attacks, \ie that one individual 
can provide two participation proofs and thus be counted twice.
That situation should be detectable.
We can do this by ensuring that Alice cannot produce two valid proofs which
are unlinkable.
\Cref{DesignatedEvent} is to prevent Alice from reusing the same proof (or proof 
share) for another event.
\Eg there might be a counter protest at the same time and place, these would 
have the same spatial and temporal properties.
To distinguish them, we also need to prove for which of these events that a 
proof is designated.
The idea is to construct a unique identifier for a protest.

We will start with the latter.
The identifier of the protest must be regulated, for the same reasons as for the 
user identifiers --- otherwise a counter-protest can simply choose the same 
protest identifier.
As was pointed out in \cref{CauseIsTheCommonDenominator}, the cause is at the 
root of what defines a protest.
The cause can be captured in some sort of \emph{manifesto}, thus, we will use 
the hash value of the manifesto as identifier of the protest (cause).
(As shown as manifesto and cause identifier \(cid\) in \cref{fig:ProofFig}.)

To practically propagate this identifier to the protesters the organizer can 
have a placard with a large QR code that either contains the entire manifesto or 
at least links to a website hosting the manifesto.
The user can scan this QR code with a protesting app which will automatically 
fetch it, show it to the protester for approval and then compute the identifier 
\(cid\).

Next we need to consider the protesters' identifiers to prevent Sybil attacks.
\Citet{HowToWinTheCloneWars} created an \emph{interactive} credential system 
which allows anonymous authentication at most \(n\) times\footnote{%
  Possibly there is another scheme that makes it non-interactive, \eg by 
  \citet{Psignatures}, see issue \#27.
}, where \(n = 1\) in our scenario.
Alice has \iac{PRF} key \(k\) and a blind signature on \(k\) included in her 
national identity-card (by assumption).
She will use \(k\) to compute \(pid\gets \ACprf[_k][cid]\), which is her 
anonymous identity during the protest (shown as \(pid\) in \cref{fig:ProofFig}).

\subsubsection{Temporal eligibility, created after start}

Given the properties of the storage (in \cref{StorageProperties}), for 
\cref{CreatedAfterStart}, each witness must include the hash value of an 
existing block in the blockchain in each proof share (shown as \(t_s\) in 
\cref{fig:ProofFig}).
Then it is clear that the proof must have been created after that block (since 
predicting such a value is hard).
This value can either be provided to the witness by the protester or the witness 
uses the value of the last known block.

\subsubsection{Location proofs and spatial eligibility}

According to \cref{SpatiallyRelated} Alice and Bob must bind their proofs 
(shares) spatially to the location, which would allow us to verify that they 
were actually in that location.
The role of the witnesses, \eg Jane, is to provide this property.
Jane can do this by using a distance-bounding protocol to ensure that the secret 
associated with Alice or Bob must be within limited physical distance.

Alice will send her \(pid\) to Jane to start the witness protocol.
Then they do the distance bounding \dots
[See issue \#22 for the discussion.]
If Jane is convinced that Alice's secret is within the desired proximity, she 
will compute her witness identifier \(wid\) and witness signature \(wsig\) and 
send them to Alice.

\subsubsection{Temporal eligibility, created before end}

The proofs (shares) can be submitted to storage in two steps:
first, committing them to the blockchain; second, to submit all the required 
data.
This will allow some time for computing all the required \ac{NIZK} proofs 
(discussed in the following section).

Given the properties of the storage system in \cref{StorageProperties}, 
\cref{CreatedBeforeEnd} is straight-forward: once a proof share is created it 
should be committed to the blockchain as soon as possible.
Thus we can infer that a proof (or proof share) was created at the latest when 
it was committed.

We note that there are at least two entities who know each proof share, the 
protester and the witness.
Alice and Bob simply commit their proofs (\ie all proof shares of their 
proofs) to the blockchain as soon as possible after they have participated in 
the protest.
The witnesses do the same, they commit all the proof shares that they helped 
create.
(Shown in \cref{fig:ProtocolOverview}.)

\subsection{Verifying the participation count}

There are three parts to verifying the participation count.
First, we must verify the eligibility of each proof, \ie of all its shares.
Second, we must count these valid proofs.
Third, each protester must check that their proof is indeed registered so that 
it can be counted.

\subsubsection{Eligibility and universal verifiability}

Universal verifiability (\cref{UniversalVerif}) means that anyone should be able 
to count the valid proofs.
To do this we must be able to verify the eligibility of a proof (\ie of all 
its shares) and then count it if valid.
To verify the eligibility of a proof share, we must verify that \(pid\), \(wid\) 
and \(wsig\) are not just randomly generated numbers but they actually depend on 
the keys \(k_P\) and \(k_W\) (as illustrated in \cref{fig:ProofFig}).
We will do this with \ac{NIZK} proofs.
We note that these proofs are not needed until the verification step after the 
protest.
Thus \(pid, wid, wsig\) can be used in the proof shares (and all computations 
above) whereas their respective \ac{NIZK} proof can be computed and published 
after the protest.

Alice must provide \iac{NIZK} proof showing that \(pid = \ACprf[_{k_P}][cid]\) 
and that she knows a signature by the identity authority on \(k_P\).
\dots
[Details of how to do this, or maybe that will be in \cref{BuildingBlocks}. See 
issue \#27 for discussion.]

In the same manner, each witness must also provide \iac{NIZK} proofs for \(wid = 
  \ACprf[_{k_W}][pid]\) and \(wsig = \ACprf[_{k_W}][wid, t_s, l]\) as well as 
that the witness knows a signature by the identity authority on \(k_W\).
With these \ac{NIZK} proofs anyone can verify the validity, \ie the 
eligibility, of the proof shares and thus also count them.

\subsubsection{Individual verifiability and receipt freeness}

The purpose of individual verifiability (\cref{IndividualVerif}) is to prevent 
an adversary from dropping participation proofs.
Thus each protester must verify that their own proof is indeed included.
This can be accomplished as follows.
After Alice commited to her proof (share) in the blockchain, she stores the hash 
of the block.
At a later time, she can still verify that the block is indeed still there.
At this point, this hash value is the only thing she must store for individual 
verifiability.

More specifically, to achieve receipt freeness (\cref{ReceiptFreeness}) Alice 
must remove her secret \ac{PRF} key, \(k_A\).
With this key Grace can verify that Alice has submitted a proof by computing 
\(pid'\gets \ACprf[_{k_A}][cid]\) and compare \(pid = pid'\).
